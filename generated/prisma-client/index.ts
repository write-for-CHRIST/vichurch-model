// Code generated by Prisma (prisma@1.26.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  activityAttendance: (
    where?: ActivityAttendanceWhereInput
  ) => Promise<boolean>;
  activitySchedule: (where?: ActivityScheduleWhereInput) => Promise<boolean>;
  activityType: (where?: ActivityTypeWhereInput) => Promise<boolean>;
  address: (where?: AddressWhereInput) => Promise<boolean>;
  commune: (where?: CommuneWhereInput) => Promise<boolean>;
  district: (where?: DistrictWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  memberType: (where?: MemberTypeWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  province: (where?: ProvinceWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activityAttendance: (
    where: ActivityAttendanceWhereUniqueInput
  ) => ActivityAttendancePromise;
  activityAttendances: (args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivityAttendance>;
  activityAttendancesConnection: (args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityAttendanceConnectionPromise;
  activitySchedule: (
    where: ActivityScheduleWhereUniqueInput
  ) => ActivitySchedulePromise;
  activitySchedules: (args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivitySchedule>;
  activitySchedulesConnection: (args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityScheduleConnectionPromise;
  activityType: (where: ActivityTypeWhereUniqueInput) => ActivityTypePromise;
  activityTypes: (args?: {
    where?: ActivityTypeWhereInput;
    orderBy?: ActivityTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivityType>;
  activityTypesConnection: (args?: {
    where?: ActivityTypeWhereInput;
    orderBy?: ActivityTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityTypeConnectionPromise;
  address: (where: AddressWhereUniqueInput) => AddressPromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  commune: (where: CommuneWhereUniqueInput) => CommunePromise;
  communes: (args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Commune>;
  communesConnection: (args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommuneConnectionPromise;
  district: (where: DistrictWhereUniqueInput) => DistrictPromise;
  districts: (args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<District>;
  districtsConnection: (args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DistrictConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupPromise;
  groups: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Group>;
  groupsConnection: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupConnectionPromise;
  memberType: (where: MemberTypeWhereUniqueInput) => MemberTypePromise;
  memberTypes: (args?: {
    where?: MemberTypeWhereInput;
    orderBy?: MemberTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MemberType>;
  memberTypesConnection: (args?: {
    where?: MemberTypeWhereInput;
    orderBy?: MemberTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MemberTypeConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  profiles: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Profile>;
  profilesConnection: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProfileConnectionPromise;
  province: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  provinces: (args?: {
    where?: ProvinceWhereInput;
    orderBy?: ProvinceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Province>;
  provincesConnection: (args?: {
    where?: ProvinceWhereInput;
    orderBy?: ProvinceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProvinceConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivityAttendance: (
    data: ActivityAttendanceCreateInput
  ) => ActivityAttendancePromise;
  updateActivityAttendance: (args: {
    data: ActivityAttendanceUpdateInput;
    where: ActivityAttendanceWhereUniqueInput;
  }) => ActivityAttendancePromise;
  updateManyActivityAttendances: (args: {
    data: ActivityAttendanceUpdateManyMutationInput;
    where?: ActivityAttendanceWhereInput;
  }) => BatchPayloadPromise;
  upsertActivityAttendance: (args: {
    where: ActivityAttendanceWhereUniqueInput;
    create: ActivityAttendanceCreateInput;
    update: ActivityAttendanceUpdateInput;
  }) => ActivityAttendancePromise;
  deleteActivityAttendance: (
    where: ActivityAttendanceWhereUniqueInput
  ) => ActivityAttendancePromise;
  deleteManyActivityAttendances: (
    where?: ActivityAttendanceWhereInput
  ) => BatchPayloadPromise;
  createActivitySchedule: (
    data: ActivityScheduleCreateInput
  ) => ActivitySchedulePromise;
  updateActivitySchedule: (args: {
    data: ActivityScheduleUpdateInput;
    where: ActivityScheduleWhereUniqueInput;
  }) => ActivitySchedulePromise;
  updateManyActivitySchedules: (args: {
    data: ActivityScheduleUpdateManyMutationInput;
    where?: ActivityScheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertActivitySchedule: (args: {
    where: ActivityScheduleWhereUniqueInput;
    create: ActivityScheduleCreateInput;
    update: ActivityScheduleUpdateInput;
  }) => ActivitySchedulePromise;
  deleteActivitySchedule: (
    where: ActivityScheduleWhereUniqueInput
  ) => ActivitySchedulePromise;
  deleteManyActivitySchedules: (
    where?: ActivityScheduleWhereInput
  ) => BatchPayloadPromise;
  createActivityType: (data: ActivityTypeCreateInput) => ActivityTypePromise;
  updateActivityType: (args: {
    data: ActivityTypeUpdateInput;
    where: ActivityTypeWhereUniqueInput;
  }) => ActivityTypePromise;
  updateManyActivityTypes: (args: {
    data: ActivityTypeUpdateManyMutationInput;
    where?: ActivityTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertActivityType: (args: {
    where: ActivityTypeWhereUniqueInput;
    create: ActivityTypeCreateInput;
    update: ActivityTypeUpdateInput;
  }) => ActivityTypePromise;
  deleteActivityType: (
    where: ActivityTypeWhereUniqueInput
  ) => ActivityTypePromise;
  deleteManyActivityTypes: (
    where?: ActivityTypeWhereInput
  ) => BatchPayloadPromise;
  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createCommune: (data: CommuneCreateInput) => CommunePromise;
  updateCommune: (args: {
    data: CommuneUpdateInput;
    where: CommuneWhereUniqueInput;
  }) => CommunePromise;
  updateManyCommunes: (args: {
    data: CommuneUpdateManyMutationInput;
    where?: CommuneWhereInput;
  }) => BatchPayloadPromise;
  upsertCommune: (args: {
    where: CommuneWhereUniqueInput;
    create: CommuneCreateInput;
    update: CommuneUpdateInput;
  }) => CommunePromise;
  deleteCommune: (where: CommuneWhereUniqueInput) => CommunePromise;
  deleteManyCommunes: (where?: CommuneWhereInput) => BatchPayloadPromise;
  createDistrict: (data: DistrictCreateInput) => DistrictPromise;
  updateDistrict: (args: {
    data: DistrictUpdateInput;
    where: DistrictWhereUniqueInput;
  }) => DistrictPromise;
  updateManyDistricts: (args: {
    data: DistrictUpdateManyMutationInput;
    where?: DistrictWhereInput;
  }) => BatchPayloadPromise;
  upsertDistrict: (args: {
    where: DistrictWhereUniqueInput;
    create: DistrictCreateInput;
    update: DistrictUpdateInput;
  }) => DistrictPromise;
  deleteDistrict: (where: DistrictWhereUniqueInput) => DistrictPromise;
  deleteManyDistricts: (where?: DistrictWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (args: {
    data: GroupUpdateInput;
    where: GroupWhereUniqueInput;
  }) => GroupPromise;
  updateManyGroups: (args: {
    data: GroupUpdateManyMutationInput;
    where?: GroupWhereInput;
  }) => BatchPayloadPromise;
  upsertGroup: (args: {
    where: GroupWhereUniqueInput;
    create: GroupCreateInput;
    update: GroupUpdateInput;
  }) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createMemberType: (data: MemberTypeCreateInput) => MemberTypePromise;
  updateMemberType: (args: {
    data: MemberTypeUpdateInput;
    where: MemberTypeWhereUniqueInput;
  }) => MemberTypePromise;
  updateManyMemberTypes: (args: {
    data: MemberTypeUpdateManyMutationInput;
    where?: MemberTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertMemberType: (args: {
    where: MemberTypeWhereUniqueInput;
    create: MemberTypeCreateInput;
    update: MemberTypeUpdateInput;
  }) => MemberTypePromise;
  deleteMemberType: (where: MemberTypeWhereUniqueInput) => MemberTypePromise;
  deleteManyMemberTypes: (where?: MemberTypeWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (args: {
    data: ProfileUpdateInput;
    where: ProfileWhereUniqueInput;
  }) => ProfilePromise;
  updateManyProfiles: (args: {
    data: ProfileUpdateManyMutationInput;
    where?: ProfileWhereInput;
  }) => BatchPayloadPromise;
  upsertProfile: (args: {
    where: ProfileWhereUniqueInput;
    create: ProfileCreateInput;
    update: ProfileUpdateInput;
  }) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createProvince: (data: ProvinceCreateInput) => ProvincePromise;
  updateProvince: (args: {
    data: ProvinceUpdateInput;
    where: ProvinceWhereUniqueInput;
  }) => ProvincePromise;
  updateManyProvinces: (args: {
    data: ProvinceUpdateManyMutationInput;
    where?: ProvinceWhereInput;
  }) => BatchPayloadPromise;
  upsertProvince: (args: {
    where: ProvinceWhereUniqueInput;
    create: ProvinceCreateInput;
    update: ProvinceUpdateInput;
  }) => ProvincePromise;
  deleteProvince: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  deleteManyProvinces: (where?: ProvinceWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activityAttendance: (
    where?: ActivityAttendanceSubscriptionWhereInput
  ) => ActivityAttendanceSubscriptionPayloadSubscription;
  activitySchedule: (
    where?: ActivityScheduleSubscriptionWhereInput
  ) => ActivityScheduleSubscriptionPayloadSubscription;
  activityType: (
    where?: ActivityTypeSubscriptionWhereInput
  ) => ActivityTypeSubscriptionPayloadSubscription;
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  commune: (
    where?: CommuneSubscriptionWhereInput
  ) => CommuneSubscriptionPayloadSubscription;
  district: (
    where?: DistrictSubscriptionWhereInput
  ) => DistrictSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  memberType: (
    where?: MemberTypeSubscriptionWhereInput
  ) => MemberTypeSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  province: (
    where?: ProvinceSubscriptionWhereInput
  ) => ProvinceSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "no_ASC"
  | "no_DESC"
  | "street_ASC"
  | "street_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityAttendanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "presence_ASC"
  | "presence_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommuneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DistrictOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "oldId_ASC"
  | "oldId_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "email_ASC"
  | "email_DESC"
  | "facebookId_ASC"
  | "facebookId_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "joinDate_ASC"
  | "joinDate_DESC"
  | "dayOfBirth_ASC"
  | "dayOfBirth_DESC"
  | "monthOfBirth_ASC"
  | "monthOfBirth_DESC"
  | "yearOfBirth_ASC"
  | "yearOfBirth_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProvinceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MemberTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface DistrictUpsertWithoutCommunesInput {
  update: DistrictUpdateWithoutCommunesDataInput;
  create: DistrictCreateWithoutCommunesInput;
}

export type ActivityAttendanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommuneUpsertWithWhereUniqueWithoutDistrictInput {
  where: CommuneWhereUniqueInput;
  update: CommuneUpdateWithoutDistrictDataInput;
  create: CommuneCreateWithoutDistrictInput;
}

export interface CommuneWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  district?: DistrictWhereInput;
  AND?: CommuneWhereInput[] | CommuneWhereInput;
  OR?: CommuneWhereInput[] | CommuneWhereInput;
  NOT?: CommuneWhereInput[] | CommuneWhereInput;
}

export interface CommuneScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CommuneScalarWhereInput[] | CommuneScalarWhereInput;
  OR?: CommuneScalarWhereInput[] | CommuneScalarWhereInput;
  NOT?: CommuneScalarWhereInput[] | CommuneScalarWhereInput;
}

export interface ProvinceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  districts_every?: DistrictWhereInput;
  districts_some?: DistrictWhereInput;
  districts_none?: DistrictWhereInput;
  AND?: ProvinceWhereInput[] | ProvinceWhereInput;
  OR?: ProvinceWhereInput[] | ProvinceWhereInput;
  NOT?: ProvinceWhereInput[] | ProvinceWhereInput;
}

export interface CommuneUpdateManyWithWhereNestedInput {
  where: CommuneScalarWhereInput;
  data: CommuneUpdateManyDataInput;
}

export interface GroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  members_every?: ProfileWhereInput;
  members_some?: ProfileWhereInput;
  members_none?: ProfileWhereInput;
  leader?: ProfileWhereInput;
  AND?: GroupWhereInput[] | GroupWhereInput;
  OR?: GroupWhereInput[] | GroupWhereInput;
  NOT?: GroupWhereInput[] | GroupWhereInput;
}

export interface ProfileCreateOneWithoutLeaderInput {
  create?: ProfileCreateWithoutLeaderInput;
  connect?: ProfileWhereUniqueInput;
}

export interface ActivityScheduleCreateWithoutActivityInput {
  start: DateTimeInput;
  end: DateTimeInput;
  attendances?: ActivityAttendanceCreateManyWithoutScheduleInput;
}

export interface ProfileCreateWithoutLeaderInput {
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressCreateOneInput;
  hometown?: ProvinceCreateOneInput;
  memberType?: MemberTypeCreateOneWithoutProfilesInput;
  group?: GroupCreateOneWithoutMembersInput;
  attendances?: ActivityAttendanceCreateManyWithoutMemberInput;
}

export interface CommuneUpdateManyDataInput {
  name?: String;
}

export interface ActivityAttendanceCreateManyWithoutMemberInput {
  create?:
    | ActivityAttendanceCreateWithoutMemberInput[]
    | ActivityAttendanceCreateWithoutMemberInput;
  connect?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
}

export interface ProvinceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProvinceWhereInput;
  AND?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
  OR?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
  NOT?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
}

export interface ActivityAttendanceCreateWithoutMemberInput {
  schedule: ActivityScheduleCreateOneWithoutAttendancesInput;
  presence: Boolean;
}

export interface MemberTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MemberTypeWhereInput;
  AND?: MemberTypeSubscriptionWhereInput[] | MemberTypeSubscriptionWhereInput;
  OR?: MemberTypeSubscriptionWhereInput[] | MemberTypeSubscriptionWhereInput;
  NOT?: MemberTypeSubscriptionWhereInput[] | MemberTypeSubscriptionWhereInput;
}

export interface GroupCreateOneWithoutLeaderInput {
  create?: GroupCreateWithoutLeaderInput;
  connect?: GroupWhereUniqueInput;
}

export interface ProfileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  oldId?: ID_Input;
  oldId_not?: ID_Input;
  oldId_in?: ID_Input[] | ID_Input;
  oldId_not_in?: ID_Input[] | ID_Input;
  oldId_lt?: ID_Input;
  oldId_lte?: ID_Input;
  oldId_gt?: ID_Input;
  oldId_gte?: ID_Input;
  oldId_contains?: ID_Input;
  oldId_not_contains?: ID_Input;
  oldId_starts_with?: ID_Input;
  oldId_not_starts_with?: ID_Input;
  oldId_ends_with?: ID_Input;
  oldId_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: Boolean;
  gender_not?: Boolean;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  facebookId?: String;
  facebookId_not?: String;
  facebookId_in?: String[] | String;
  facebookId_not_in?: String[] | String;
  facebookId_lt?: String;
  facebookId_lte?: String;
  facebookId_gt?: String;
  facebookId_gte?: String;
  facebookId_contains?: String;
  facebookId_not_contains?: String;
  facebookId_starts_with?: String;
  facebookId_not_starts_with?: String;
  facebookId_ends_with?: String;
  facebookId_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  joinDate?: DateTimeInput;
  joinDate_not?: DateTimeInput;
  joinDate_in?: DateTimeInput[] | DateTimeInput;
  joinDate_not_in?: DateTimeInput[] | DateTimeInput;
  joinDate_lt?: DateTimeInput;
  joinDate_lte?: DateTimeInput;
  joinDate_gt?: DateTimeInput;
  joinDate_gte?: DateTimeInput;
  dayOfBirth?: Int;
  dayOfBirth_not?: Int;
  dayOfBirth_in?: Int[] | Int;
  dayOfBirth_not_in?: Int[] | Int;
  dayOfBirth_lt?: Int;
  dayOfBirth_lte?: Int;
  dayOfBirth_gt?: Int;
  dayOfBirth_gte?: Int;
  monthOfBirth?: Int;
  monthOfBirth_not?: Int;
  monthOfBirth_in?: Int[] | Int;
  monthOfBirth_not_in?: Int[] | Int;
  monthOfBirth_lt?: Int;
  monthOfBirth_lte?: Int;
  monthOfBirth_gt?: Int;
  monthOfBirth_gte?: Int;
  yearOfBirth?: Int;
  yearOfBirth_not?: Int;
  yearOfBirth_in?: Int[] | Int;
  yearOfBirth_not_in?: Int[] | Int;
  yearOfBirth_lt?: Int;
  yearOfBirth_lte?: Int;
  yearOfBirth_gt?: Int;
  yearOfBirth_gte?: Int;
  address?: AddressWhereInput;
  hometown?: ProvinceWhereInput;
  memberType?: MemberTypeWhereInput;
  group?: GroupWhereInput;
  leader?: GroupWhereInput;
  attendances_every?: ActivityAttendanceWhereInput;
  attendances_some?: ActivityAttendanceWhereInput;
  attendances_none?: ActivityAttendanceWhereInput;
  AND?: ProfileWhereInput[] | ProfileWhereInput;
  OR?: ProfileWhereInput[] | ProfileWhereInput;
  NOT?: ProfileWhereInput[] | ProfileWhereInput;
}

export interface GroupCreateWithoutLeaderInput {
  name: String;
  members?: ProfileCreateManyWithoutGroupInput;
}

export interface ActivityAttendanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  schedule?: ActivityScheduleWhereInput;
  member?: ProfileWhereInput;
  presence?: Boolean;
  presence_not?: Boolean;
  AND?: ActivityAttendanceWhereInput[] | ActivityAttendanceWhereInput;
  OR?: ActivityAttendanceWhereInput[] | ActivityAttendanceWhereInput;
  NOT?: ActivityAttendanceWhereInput[] | ActivityAttendanceWhereInput;
}

export interface ProfileCreateManyWithoutGroupInput {
  create?: ProfileCreateWithoutGroupInput[] | ProfileCreateWithoutGroupInput;
  connect?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  OR?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  NOT?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export interface ProfileCreateWithoutGroupInput {
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressCreateOneInput;
  hometown?: ProvinceCreateOneInput;
  memberType?: MemberTypeCreateOneWithoutProfilesInput;
  leader?: GroupCreateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceCreateManyWithoutMemberInput;
}

export interface ActivityScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivityScheduleWhereInput;
  AND?:
    | ActivityScheduleSubscriptionWhereInput[]
    | ActivityScheduleSubscriptionWhereInput;
  OR?:
    | ActivityScheduleSubscriptionWhereInput[]
    | ActivityScheduleSubscriptionWhereInput;
  NOT?:
    | ActivityScheduleSubscriptionWhereInput[]
    | ActivityScheduleSubscriptionWhereInput;
}

export interface ActivityAttendanceUpdateInput {
  schedule?: ActivityScheduleUpdateOneRequiredWithoutAttendancesInput;
  member?: ProfileUpdateOneRequiredWithoutAttendancesInput;
  presence?: Boolean;
}

export type ActivityScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ActivityScheduleUpdateOneRequiredWithoutAttendancesInput {
  create?: ActivityScheduleCreateWithoutAttendancesInput;
  update?: ActivityScheduleUpdateWithoutAttendancesDataInput;
  upsert?: ActivityScheduleUpsertWithoutAttendancesInput;
  connect?: ActivityScheduleWhereUniqueInput;
}

export interface ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput;
  create: ProfileCreateInput;
}

export interface ActivityScheduleUpdateWithoutAttendancesDataInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  activity?: ActivityTypeUpdateOneRequiredWithoutSchedulesInput;
}

export type ActivityTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ActivityTypeUpdateOneRequiredWithoutSchedulesInput {
  create?: ActivityTypeCreateWithoutSchedulesInput;
  update?: ActivityTypeUpdateWithoutSchedulesDataInput;
  upsert?: ActivityTypeUpsertWithoutSchedulesInput;
  connect?: ActivityTypeWhereUniqueInput;
}

export interface ProfileUpdateOneInput {
  create?: ProfileCreateInput;
  update?: ProfileUpdateDataInput;
  upsert?: ProfileUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProfileWhereUniqueInput;
}

export interface ActivityTypeUpdateWithoutSchedulesDataInput {
  name?: String;
}

export interface ProfileCreateOneInput {
  create?: ProfileCreateInput;
  connect?: ProfileWhereUniqueInput;
}

export interface ActivityTypeUpsertWithoutSchedulesInput {
  update: ActivityTypeUpdateWithoutSchedulesDataInput;
  create: ActivityTypeCreateWithoutSchedulesInput;
}

export interface ActivityScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  activity?: ActivityTypeWhereInput;
  attendances_every?: ActivityAttendanceWhereInput;
  attendances_some?: ActivityAttendanceWhereInput;
  attendances_none?: ActivityAttendanceWhereInput;
  AND?: ActivityScheduleWhereInput[] | ActivityScheduleWhereInput;
  OR?: ActivityScheduleWhereInput[] | ActivityScheduleWhereInput;
  NOT?: ActivityScheduleWhereInput[] | ActivityScheduleWhereInput;
}

export interface ActivityScheduleUpsertWithoutAttendancesInput {
  update: ActivityScheduleUpdateWithoutAttendancesDataInput;
  create: ActivityScheduleCreateWithoutAttendancesInput;
}

export interface ProvinceUpdateManyMutationInput {
  name?: String;
}

export interface ProfileUpdateOneRequiredWithoutAttendancesInput {
  create?: ProfileCreateWithoutAttendancesInput;
  update?: ProfileUpdateWithoutAttendancesDataInput;
  upsert?: ProfileUpsertWithoutAttendancesInput;
  connect?: ProfileWhereUniqueInput;
}

export type CommuneWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProfileUpdateWithoutAttendancesDataInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressUpdateOneInput;
  hometown?: ProvinceUpdateOneInput;
  memberType?: MemberTypeUpdateOneWithoutProfilesInput;
  group?: GroupUpdateOneWithoutMembersInput;
  leader?: GroupUpdateOneWithoutLeaderInput;
}

export interface ProfileUpdateInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressUpdateOneInput;
  hometown?: ProvinceUpdateOneInput;
  memberType?: MemberTypeUpdateOneWithoutProfilesInput;
  group?: GroupUpdateOneWithoutMembersInput;
  leader?: GroupUpdateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceUpdateManyWithoutMemberInput;
}

export interface AddressUpdateOneInput {
  create?: AddressCreateInput;
  update?: AddressUpdateDataInput;
  upsert?: AddressUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AddressWhereUniqueInput;
}

export type DistrictWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressUpdateDataInput {
  no?: String;
  street?: String;
  commune?: CommuneUpdateOneInput;
  district?: DistrictUpdateOneInput;
  province?: ProvinceUpdateOneInput;
}

export interface ProfileUpsertWithWhereUniqueWithoutMemberTypeInput {
  where: ProfileWhereUniqueInput;
  update: ProfileUpdateWithoutMemberTypeDataInput;
  create: ProfileCreateWithoutMemberTypeInput;
}

export interface CommuneUpdateOneInput {
  create?: CommuneCreateInput;
  update?: CommuneUpdateDataInput;
  upsert?: CommuneUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommuneWhereUniqueInput;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommuneUpdateDataInput {
  name?: String;
  district?: DistrictUpdateOneRequiredWithoutCommunesInput;
}

export interface ProfileUpdateManyWithoutMemberTypeInput {
  create?:
    | ProfileCreateWithoutMemberTypeInput[]
    | ProfileCreateWithoutMemberTypeInput;
  delete?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  connect?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  set?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  disconnect?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  update?:
    | ProfileUpdateWithWhereUniqueWithoutMemberTypeInput[]
    | ProfileUpdateWithWhereUniqueWithoutMemberTypeInput;
  upsert?:
    | ProfileUpsertWithWhereUniqueWithoutMemberTypeInput[]
    | ProfileUpsertWithWhereUniqueWithoutMemberTypeInput;
  deleteMany?: ProfileScalarWhereInput[] | ProfileScalarWhereInput;
  updateMany?:
    | ProfileUpdateManyWithWhereNestedInput[]
    | ProfileUpdateManyWithWhereNestedInput;
}

export interface DistrictUpdateOneRequiredWithoutCommunesInput {
  create?: DistrictCreateWithoutCommunesInput;
  update?: DistrictUpdateWithoutCommunesDataInput;
  upsert?: DistrictUpsertWithoutCommunesInput;
  connect?: DistrictWhereUniqueInput;
}

export interface ProfileCreateWithoutMemberTypeInput {
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressCreateOneInput;
  hometown?: ProvinceCreateOneInput;
  group?: GroupCreateOneWithoutMembersInput;
  leader?: GroupCreateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceCreateManyWithoutMemberInput;
}

export interface DistrictUpdateWithoutCommunesDataInput {
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutDistrictsInput;
}

export interface ProfileCreateManyWithoutMemberTypeInput {
  create?:
    | ProfileCreateWithoutMemberTypeInput[]
    | ProfileCreateWithoutMemberTypeInput;
  connect?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
}

export interface ProvinceUpdateOneRequiredWithoutDistrictsInput {
  create?: ProvinceCreateWithoutDistrictsInput;
  update?: ProvinceUpdateWithoutDistrictsDataInput;
  upsert?: ProvinceUpsertWithoutDistrictsInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface GroupUpdateManyMutationInput {
  name?: String;
}

export interface ProvinceUpdateWithoutDistrictsDataInput {
  name?: String;
}

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  oldId?: ID_Input;
}>;

export interface ProvinceUpsertWithoutDistrictsInput {
  update: ProvinceUpdateWithoutDistrictsDataInput;
  create: ProvinceCreateWithoutDistrictsInput;
}

export interface DistrictUpdateManyMutationInput {
  name?: String;
}

export interface ActivityScheduleUpdateWithoutActivityDataInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  attendances?: ActivityAttendanceUpdateManyWithoutScheduleInput;
}

export type ProvinceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommuneUpsertNestedInput {
  update: CommuneUpdateDataInput;
  create: CommuneCreateInput;
}

export interface CommuneUpdateInput {
  name?: String;
  district?: DistrictUpdateOneRequiredWithoutCommunesInput;
}

export interface DistrictUpdateOneInput {
  create?: DistrictCreateInput;
  update?: DistrictUpdateDataInput;
  upsert?: DistrictUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DistrictWhereUniqueInput;
}

export interface AddressUpdateInput {
  no?: String;
  street?: String;
  commune?: CommuneUpdateOneInput;
  district?: DistrictUpdateOneInput;
  province?: ProvinceUpdateOneInput;
}

export interface DistrictUpdateDataInput {
  name?: String;
  communes?: CommuneUpdateManyWithoutDistrictInput;
  province?: ProvinceUpdateOneRequiredWithoutDistrictsInput;
}

export interface ActivityTypeUpdateManyMutationInput {
  name?: String;
}

export interface CommuneUpdateManyWithoutDistrictInput {
  create?:
    | CommuneCreateWithoutDistrictInput[]
    | CommuneCreateWithoutDistrictInput;
  delete?: CommuneWhereUniqueInput[] | CommuneWhereUniqueInput;
  connect?: CommuneWhereUniqueInput[] | CommuneWhereUniqueInput;
  set?: CommuneWhereUniqueInput[] | CommuneWhereUniqueInput;
  disconnect?: CommuneWhereUniqueInput[] | CommuneWhereUniqueInput;
  update?:
    | CommuneUpdateWithWhereUniqueWithoutDistrictInput[]
    | CommuneUpdateWithWhereUniqueWithoutDistrictInput;
  upsert?:
    | CommuneUpsertWithWhereUniqueWithoutDistrictInput[]
    | CommuneUpsertWithWhereUniqueWithoutDistrictInput;
  deleteMany?: CommuneScalarWhereInput[] | CommuneScalarWhereInput;
  updateMany?:
    | CommuneUpdateManyWithWhereNestedInput[]
    | CommuneUpdateManyWithWhereNestedInput;
}

export interface ActivityScheduleUpdateManyDataInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
}

export interface CommuneUpdateWithWhereUniqueWithoutDistrictInput {
  where: CommuneWhereUniqueInput;
  data: CommuneUpdateWithoutDistrictDataInput;
}

export interface ActivityScheduleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  AND?: ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput;
  OR?: ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput;
  NOT?: ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput;
}

export interface CommuneUpdateWithoutDistrictDataInput {
  name?: String;
}

export interface ActivityScheduleCreateOneWithoutAttendancesInput {
  create?: ActivityScheduleCreateWithoutAttendancesInput;
  connect?: ActivityScheduleWhereUniqueInput;
}

export interface DistrictWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  communes_every?: CommuneWhereInput;
  communes_some?: CommuneWhereInput;
  communes_none?: CommuneWhereInput;
  province?: ProvinceWhereInput;
  AND?: DistrictWhereInput[] | DistrictWhereInput;
  OR?: DistrictWhereInput[] | DistrictWhereInput;
  NOT?: DistrictWhereInput[] | DistrictWhereInput;
}

export interface ActivityTypeCreateOneWithoutSchedulesInput {
  create?: ActivityTypeCreateWithoutSchedulesInput;
  connect?: ActivityTypeWhereUniqueInput;
}

export interface MemberTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  profiles_every?: ProfileWhereInput;
  profiles_some?: ProfileWhereInput;
  profiles_none?: ProfileWhereInput;
  AND?: MemberTypeWhereInput[] | MemberTypeWhereInput;
  OR?: MemberTypeWhereInput[] | MemberTypeWhereInput;
  NOT?: MemberTypeWhereInput[] | MemberTypeWhereInput;
}

export interface ProfileCreateOneWithoutAttendancesInput {
  create?: ProfileCreateWithoutAttendancesInput;
  connect?: ProfileWhereUniqueInput;
}

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  no?: String;
  no_not?: String;
  no_in?: String[] | String;
  no_not_in?: String[] | String;
  no_lt?: String;
  no_lte?: String;
  no_gt?: String;
  no_gte?: String;
  no_contains?: String;
  no_not_contains?: String;
  no_starts_with?: String;
  no_not_starts_with?: String;
  no_ends_with?: String;
  no_not_ends_with?: String;
  street?: String;
  street_not?: String;
  street_in?: String[] | String;
  street_not_in?: String[] | String;
  street_lt?: String;
  street_lte?: String;
  street_gt?: String;
  street_gte?: String;
  street_contains?: String;
  street_not_contains?: String;
  street_starts_with?: String;
  street_not_starts_with?: String;
  street_ends_with?: String;
  street_not_ends_with?: String;
  commune?: CommuneWhereInput;
  district?: DistrictWhereInput;
  province?: ProvinceWhereInput;
  AND?: AddressWhereInput[] | AddressWhereInput;
  OR?: AddressWhereInput[] | AddressWhereInput;
  NOT?: AddressWhereInput[] | AddressWhereInput;
}

export interface AddressCreateOneInput {
  create?: AddressCreateInput;
  connect?: AddressWhereUniqueInput;
}

export interface ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput {
  where: ActivityScheduleWhereUniqueInput;
  data: ActivityScheduleUpdateWithoutActivityDataInput;
}

export interface CommuneCreateOneInput {
  create?: CommuneCreateInput;
  connect?: CommuneWhereUniqueInput;
}

export interface DistrictUpsertNestedInput {
  update: DistrictUpdateDataInput;
  create: DistrictCreateInput;
}

export interface DistrictCreateOneWithoutCommunesInput {
  create?: DistrictCreateWithoutCommunesInput;
  connect?: DistrictWhereUniqueInput;
}

export interface ProvinceUpdateOneInput {
  create?: ProvinceCreateInput;
  update?: ProvinceUpdateDataInput;
  upsert?: ProvinceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProvinceWhereUniqueInput;
}

export interface ProvinceCreateOneWithoutDistrictsInput {
  create?: ProvinceCreateWithoutDistrictsInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface ProvinceUpdateDataInput {
  name?: String;
  districts?: DistrictUpdateManyWithoutProvinceInput;
}

export interface DistrictCreateOneInput {
  create?: DistrictCreateInput;
  connect?: DistrictWhereUniqueInput;
}

export interface DistrictUpdateManyWithoutProvinceInput {
  create?:
    | DistrictCreateWithoutProvinceInput[]
    | DistrictCreateWithoutProvinceInput;
  delete?: DistrictWhereUniqueInput[] | DistrictWhereUniqueInput;
  connect?: DistrictWhereUniqueInput[] | DistrictWhereUniqueInput;
  set?: DistrictWhereUniqueInput[] | DistrictWhereUniqueInput;
  disconnect?: DistrictWhereUniqueInput[] | DistrictWhereUniqueInput;
  update?:
    | DistrictUpdateWithWhereUniqueWithoutProvinceInput[]
    | DistrictUpdateWithWhereUniqueWithoutProvinceInput;
  upsert?:
    | DistrictUpsertWithWhereUniqueWithoutProvinceInput[]
    | DistrictUpsertWithWhereUniqueWithoutProvinceInput;
  deleteMany?: DistrictScalarWhereInput[] | DistrictScalarWhereInput;
  updateMany?:
    | DistrictUpdateManyWithWhereNestedInput[]
    | DistrictUpdateManyWithWhereNestedInput;
}

export interface CommuneCreateManyWithoutDistrictInput {
  create?:
    | CommuneCreateWithoutDistrictInput[]
    | CommuneCreateWithoutDistrictInput;
  connect?: CommuneWhereUniqueInput[] | CommuneWhereUniqueInput;
}

export interface DistrictUpdateWithWhereUniqueWithoutProvinceInput {
  where: DistrictWhereUniqueInput;
  data: DistrictUpdateWithoutProvinceDataInput;
}

export interface ProvinceCreateOneInput {
  create?: ProvinceCreateInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface DistrictUpdateWithoutProvinceDataInput {
  name?: String;
  communes?: CommuneUpdateManyWithoutDistrictInput;
}

export interface DistrictCreateManyWithoutProvinceInput {
  create?:
    | DistrictCreateWithoutProvinceInput[]
    | DistrictCreateWithoutProvinceInput;
  connect?: DistrictWhereUniqueInput[] | DistrictWhereUniqueInput;
}

export interface DistrictUpsertWithWhereUniqueWithoutProvinceInput {
  where: DistrictWhereUniqueInput;
  update: DistrictUpdateWithoutProvinceDataInput;
  create: DistrictCreateWithoutProvinceInput;
}

export interface MemberTypeCreateOneWithoutProfilesInput {
  create?: MemberTypeCreateWithoutProfilesInput;
  connect?: MemberTypeWhereUniqueInput;
}

export interface DistrictScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: DistrictScalarWhereInput[] | DistrictScalarWhereInput;
  OR?: DistrictScalarWhereInput[] | DistrictScalarWhereInput;
  NOT?: DistrictScalarWhereInput[] | DistrictScalarWhereInput;
}

export interface GroupCreateOneWithoutMembersInput {
  create?: GroupCreateWithoutMembersInput;
  connect?: GroupWhereUniqueInput;
}

export interface DistrictUpdateManyWithWhereNestedInput {
  where: DistrictScalarWhereInput;
  data: DistrictUpdateManyDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface DistrictUpdateManyDataInput {
  name?: String;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupWhereInput;
  AND?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  OR?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  NOT?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
}

export interface ProvinceUpsertNestedInput {
  update: ProvinceUpdateDataInput;
  create: ProvinceCreateInput;
}

export interface CommuneSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommuneWhereInput;
  AND?: CommuneSubscriptionWhereInput[] | CommuneSubscriptionWhereInput;
  OR?: CommuneSubscriptionWhereInput[] | CommuneSubscriptionWhereInput;
  NOT?: CommuneSubscriptionWhereInput[] | CommuneSubscriptionWhereInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface ActivityAttendanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivityAttendanceWhereInput;
  AND?:
    | ActivityAttendanceSubscriptionWhereInput[]
    | ActivityAttendanceSubscriptionWhereInput;
  OR?:
    | ActivityAttendanceSubscriptionWhereInput[]
    | ActivityAttendanceSubscriptionWhereInput;
  NOT?:
    | ActivityAttendanceSubscriptionWhereInput[]
    | ActivityAttendanceSubscriptionWhereInput;
}

export interface MemberTypeUpdateOneWithoutProfilesInput {
  create?: MemberTypeCreateWithoutProfilesInput;
  update?: MemberTypeUpdateWithoutProfilesDataInput;
  upsert?: MemberTypeUpsertWithoutProfilesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MemberTypeWhereUniqueInput;
}

export interface ProfileUpdateDataInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressUpdateOneInput;
  hometown?: ProvinceUpdateOneInput;
  memberType?: MemberTypeUpdateOneWithoutProfilesInput;
  group?: GroupUpdateOneWithoutMembersInput;
  leader?: GroupUpdateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceUpdateManyWithoutMemberInput;
}

export interface MemberTypeUpdateWithoutProfilesDataInput {
  name?: String;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  role?: Int;
  active?: Boolean;
  profile?: ProfileUpdateOneInput;
}

export interface MemberTypeUpsertWithoutProfilesInput {
  update: MemberTypeUpdateWithoutProfilesDataInput;
  create: MemberTypeCreateWithoutProfilesInput;
}

export interface UserCreateInput {
  username: String;
  password: String;
  role?: Int;
  active?: Boolean;
  profile?: ProfileCreateOneInput;
}

export interface GroupUpdateOneWithoutMembersInput {
  create?: GroupCreateWithoutMembersInput;
  update?: GroupUpdateWithoutMembersDataInput;
  upsert?: GroupUpsertWithoutMembersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GroupWhereUniqueInput;
}

export interface ProfileUpdateManyMutationInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
}

export interface GroupUpdateWithoutMembersDataInput {
  name?: String;
  leader?: ProfileUpdateOneWithoutLeaderInput;
}

export interface MemberTypeUpdateManyMutationInput {
  name?: String;
}

export interface ProfileUpdateOneWithoutLeaderInput {
  create?: ProfileCreateWithoutLeaderInput;
  update?: ProfileUpdateWithoutLeaderDataInput;
  upsert?: ProfileUpsertWithoutLeaderInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProfileWhereUniqueInput;
}

export interface ProfileUpdateWithWhereUniqueWithoutMemberTypeInput {
  where: ProfileWhereUniqueInput;
  data: ProfileUpdateWithoutMemberTypeDataInput;
}

export interface ProfileUpdateWithoutLeaderDataInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressUpdateOneInput;
  hometown?: ProvinceUpdateOneInput;
  memberType?: MemberTypeUpdateOneWithoutProfilesInput;
  group?: GroupUpdateOneWithoutMembersInput;
  attendances?: ActivityAttendanceUpdateManyWithoutMemberInput;
}

export type MemberTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ActivityAttendanceUpdateManyWithoutMemberInput {
  create?:
    | ActivityAttendanceCreateWithoutMemberInput[]
    | ActivityAttendanceCreateWithoutMemberInput;
  delete?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  connect?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  set?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  disconnect?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  update?:
    | ActivityAttendanceUpdateWithWhereUniqueWithoutMemberInput[]
    | ActivityAttendanceUpdateWithWhereUniqueWithoutMemberInput;
  upsert?:
    | ActivityAttendanceUpsertWithWhereUniqueWithoutMemberInput[]
    | ActivityAttendanceUpsertWithWhereUniqueWithoutMemberInput;
  deleteMany?:
    | ActivityAttendanceScalarWhereInput[]
    | ActivityAttendanceScalarWhereInput;
  updateMany?:
    | ActivityAttendanceUpdateManyWithWhereNestedInput[]
    | ActivityAttendanceUpdateManyWithWhereNestedInput;
}

export interface GroupUpdateInput {
  name?: String;
  members?: ProfileUpdateManyWithoutGroupInput;
  leader?: ProfileUpdateOneWithoutLeaderInput;
}

export interface ActivityAttendanceUpdateWithWhereUniqueWithoutMemberInput {
  where: ActivityAttendanceWhereUniqueInput;
  data: ActivityAttendanceUpdateWithoutMemberDataInput;
}

export interface DistrictUpdateInput {
  name?: String;
  communes?: CommuneUpdateManyWithoutDistrictInput;
  province?: ProvinceUpdateOneRequiredWithoutDistrictsInput;
}

export interface ActivityAttendanceUpdateWithoutMemberDataInput {
  schedule?: ActivityScheduleUpdateOneRequiredWithoutAttendancesInput;
  presence?: Boolean;
}

export interface AddressUpdateManyMutationInput {
  no?: String;
  street?: String;
}

export interface ActivityAttendanceUpsertWithWhereUniqueWithoutMemberInput {
  where: ActivityAttendanceWhereUniqueInput;
  update: ActivityAttendanceUpdateWithoutMemberDataInput;
  create: ActivityAttendanceCreateWithoutMemberInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: Int;
  role_not?: Int;
  role_in?: Int[] | Int;
  role_not_in?: Int[] | Int;
  role_lt?: Int;
  role_lte?: Int;
  role_gt?: Int;
  role_gte?: Int;
  active?: Boolean;
  active_not?: Boolean;
  profile?: ProfileWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ActivityAttendanceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  presence?: Boolean;
  presence_not?: Boolean;
  AND?:
    | ActivityAttendanceScalarWhereInput[]
    | ActivityAttendanceScalarWhereInput;
  OR?:
    | ActivityAttendanceScalarWhereInput[]
    | ActivityAttendanceScalarWhereInput;
  NOT?:
    | ActivityAttendanceScalarWhereInput[]
    | ActivityAttendanceScalarWhereInput;
}

export interface ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput {
  where: ActivityScheduleWhereUniqueInput;
  update: ActivityScheduleUpdateWithoutActivityDataInput;
  create: ActivityScheduleCreateWithoutActivityInput;
}

export interface ActivityAttendanceUpdateManyWithWhereNestedInput {
  where: ActivityAttendanceScalarWhereInput;
  data: ActivityAttendanceUpdateManyDataInput;
}

export interface ActivityScheduleCreateWithoutAttendancesInput {
  start: DateTimeInput;
  end: DateTimeInput;
  activity: ActivityTypeCreateOneWithoutSchedulesInput;
}

export interface ActivityAttendanceUpdateManyDataInput {
  presence?: Boolean;
}

export interface ProfileCreateWithoutAttendancesInput {
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressCreateOneInput;
  hometown?: ProvinceCreateOneInput;
  memberType?: MemberTypeCreateOneWithoutProfilesInput;
  group?: GroupCreateOneWithoutMembersInput;
  leader?: GroupCreateOneWithoutLeaderInput;
}

export interface ProfileUpsertWithoutLeaderInput {
  update: ProfileUpdateWithoutLeaderDataInput;
  create: ProfileCreateWithoutLeaderInput;
}

export interface CommuneCreateInput {
  name: String;
  district: DistrictCreateOneWithoutCommunesInput;
}

export interface GroupUpsertWithoutMembersInput {
  update: GroupUpdateWithoutMembersDataInput;
  create: GroupCreateWithoutMembersInput;
}

export interface ProvinceCreateWithoutDistrictsInput {
  name: String;
}

export interface GroupUpdateOneWithoutLeaderInput {
  create?: GroupCreateWithoutLeaderInput;
  update?: GroupUpdateWithoutLeaderDataInput;
  upsert?: GroupUpsertWithoutLeaderInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GroupWhereUniqueInput;
}

export interface CommuneCreateWithoutDistrictInput {
  name: String;
}

export interface GroupUpdateWithoutLeaderDataInput {
  name?: String;
  members?: ProfileUpdateManyWithoutGroupInput;
}

export interface DistrictCreateWithoutProvinceInput {
  name: String;
  communes?: CommuneCreateManyWithoutDistrictInput;
}

export interface ProfileUpdateManyWithoutGroupInput {
  create?: ProfileCreateWithoutGroupInput[] | ProfileCreateWithoutGroupInput;
  delete?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  connect?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  set?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  disconnect?: ProfileWhereUniqueInput[] | ProfileWhereUniqueInput;
  update?:
    | ProfileUpdateWithWhereUniqueWithoutGroupInput[]
    | ProfileUpdateWithWhereUniqueWithoutGroupInput;
  upsert?:
    | ProfileUpsertWithWhereUniqueWithoutGroupInput[]
    | ProfileUpsertWithWhereUniqueWithoutGroupInput;
  deleteMany?: ProfileScalarWhereInput[] | ProfileScalarWhereInput;
  updateMany?:
    | ProfileUpdateManyWithWhereNestedInput[]
    | ProfileUpdateManyWithWhereNestedInput;
}

export interface GroupCreateWithoutMembersInput {
  name: String;
  leader?: ProfileCreateOneWithoutLeaderInput;
}

export interface ProfileUpdateWithWhereUniqueWithoutGroupInput {
  where: ProfileWhereUniqueInput;
  data: ProfileUpdateWithoutGroupDataInput;
}

export interface DistrictSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DistrictWhereInput;
  AND?: DistrictSubscriptionWhereInput[] | DistrictSubscriptionWhereInput;
  OR?: DistrictSubscriptionWhereInput[] | DistrictSubscriptionWhereInput;
  NOT?: DistrictSubscriptionWhereInput[] | DistrictSubscriptionWhereInput;
}

export interface ProfileUpdateWithoutGroupDataInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressUpdateOneInput;
  hometown?: ProvinceUpdateOneInput;
  memberType?: MemberTypeUpdateOneWithoutProfilesInput;
  leader?: GroupUpdateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceUpdateManyWithoutMemberInput;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
  role?: Int;
  active?: Boolean;
}

export interface ProfileUpsertWithWhereUniqueWithoutGroupInput {
  where: ProfileWhereUniqueInput;
  update: ProfileUpdateWithoutGroupDataInput;
  create: ProfileCreateWithoutGroupInput;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProfileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  oldId?: ID_Input;
  oldId_not?: ID_Input;
  oldId_in?: ID_Input[] | ID_Input;
  oldId_not_in?: ID_Input[] | ID_Input;
  oldId_lt?: ID_Input;
  oldId_lte?: ID_Input;
  oldId_gt?: ID_Input;
  oldId_gte?: ID_Input;
  oldId_contains?: ID_Input;
  oldId_not_contains?: ID_Input;
  oldId_starts_with?: ID_Input;
  oldId_not_starts_with?: ID_Input;
  oldId_ends_with?: ID_Input;
  oldId_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: Boolean;
  gender_not?: Boolean;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  facebookId?: String;
  facebookId_not?: String;
  facebookId_in?: String[] | String;
  facebookId_not_in?: String[] | String;
  facebookId_lt?: String;
  facebookId_lte?: String;
  facebookId_gt?: String;
  facebookId_gte?: String;
  facebookId_contains?: String;
  facebookId_not_contains?: String;
  facebookId_starts_with?: String;
  facebookId_not_starts_with?: String;
  facebookId_ends_with?: String;
  facebookId_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  joinDate?: DateTimeInput;
  joinDate_not?: DateTimeInput;
  joinDate_in?: DateTimeInput[] | DateTimeInput;
  joinDate_not_in?: DateTimeInput[] | DateTimeInput;
  joinDate_lt?: DateTimeInput;
  joinDate_lte?: DateTimeInput;
  joinDate_gt?: DateTimeInput;
  joinDate_gte?: DateTimeInput;
  dayOfBirth?: Int;
  dayOfBirth_not?: Int;
  dayOfBirth_in?: Int[] | Int;
  dayOfBirth_not_in?: Int[] | Int;
  dayOfBirth_lt?: Int;
  dayOfBirth_lte?: Int;
  dayOfBirth_gt?: Int;
  dayOfBirth_gte?: Int;
  monthOfBirth?: Int;
  monthOfBirth_not?: Int;
  monthOfBirth_in?: Int[] | Int;
  monthOfBirth_not_in?: Int[] | Int;
  monthOfBirth_lt?: Int;
  monthOfBirth_lte?: Int;
  monthOfBirth_gt?: Int;
  monthOfBirth_gte?: Int;
  yearOfBirth?: Int;
  yearOfBirth_not?: Int;
  yearOfBirth_in?: Int[] | Int;
  yearOfBirth_not_in?: Int[] | Int;
  yearOfBirth_lt?: Int;
  yearOfBirth_lte?: Int;
  yearOfBirth_gt?: Int;
  yearOfBirth_gte?: Int;
  AND?: ProfileScalarWhereInput[] | ProfileScalarWhereInput;
  OR?: ProfileScalarWhereInput[] | ProfileScalarWhereInput;
  NOT?: ProfileScalarWhereInput[] | ProfileScalarWhereInput;
}

export interface ProfileCreateInput {
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressCreateOneInput;
  hometown?: ProvinceCreateOneInput;
  memberType?: MemberTypeCreateOneWithoutProfilesInput;
  group?: GroupCreateOneWithoutMembersInput;
  leader?: GroupCreateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceCreateManyWithoutMemberInput;
}

export interface ProfileUpdateManyWithWhereNestedInput {
  where: ProfileScalarWhereInput;
  data: ProfileUpdateManyDataInput;
}

export interface MemberTypeUpdateInput {
  name?: String;
  profiles?: ProfileUpdateManyWithoutMemberTypeInput;
}

export interface ProfileUpdateManyDataInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
}

export interface GroupCreateInput {
  name: String;
  members?: ProfileCreateManyWithoutGroupInput;
  leader?: ProfileCreateOneWithoutLeaderInput;
}

export interface GroupUpsertWithoutLeaderInput {
  update: GroupUpdateWithoutLeaderDataInput;
  create: GroupCreateWithoutLeaderInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface ProfileUpsertWithoutAttendancesInput {
  update: ProfileUpdateWithoutAttendancesDataInput;
  create: ProfileCreateWithoutAttendancesInput;
}

export interface ActivityAttendanceCreateInput {
  schedule: ActivityScheduleCreateOneWithoutAttendancesInput;
  member: ProfileCreateOneWithoutAttendancesInput;
  presence: Boolean;
}

export interface ActivityAttendanceUpdateManyMutationInput {
  presence?: Boolean;
}

export interface AddressCreateInput {
  no?: String;
  street?: String;
  commune?: CommuneCreateOneInput;
  district?: DistrictCreateOneInput;
  province?: ProvinceCreateOneInput;
}

export interface ActivityScheduleUpdateManyWithoutActivityInput {
  create?:
    | ActivityScheduleCreateWithoutActivityInput[]
    | ActivityScheduleCreateWithoutActivityInput;
  delete?:
    | ActivityScheduleWhereUniqueInput[]
    | ActivityScheduleWhereUniqueInput;
  connect?:
    | ActivityScheduleWhereUniqueInput[]
    | ActivityScheduleWhereUniqueInput;
  set?: ActivityScheduleWhereUniqueInput[] | ActivityScheduleWhereUniqueInput;
  disconnect?:
    | ActivityScheduleWhereUniqueInput[]
    | ActivityScheduleWhereUniqueInput;
  update?:
    | ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput[]
    | ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput;
  upsert?:
    | ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput[]
    | ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput;
  deleteMany?:
    | ActivityScheduleScalarWhereInput[]
    | ActivityScheduleScalarWhereInput;
  updateMany?:
    | ActivityScheduleUpdateManyWithWhereNestedInput[]
    | ActivityScheduleUpdateManyWithWhereNestedInput;
}

export interface DistrictCreateInput {
  name: String;
  communes?: CommuneCreateManyWithoutDistrictInput;
  province: ProvinceCreateOneWithoutDistrictsInput;
}

export interface ActivityTypeUpdateInput {
  name?: String;
  schedules?: ActivityScheduleUpdateManyWithoutActivityInput;
}

export interface MemberTypeCreateWithoutProfilesInput {
  name: String;
}

export interface ActivityScheduleCreateInput {
  start: DateTimeInput;
  end: DateTimeInput;
  activity: ActivityTypeCreateOneWithoutSchedulesInput;
  attendances?: ActivityAttendanceCreateManyWithoutScheduleInput;
}

export interface ActivityTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivityTypeWhereInput;
  AND?:
    | ActivityTypeSubscriptionWhereInput[]
    | ActivityTypeSubscriptionWhereInput;
  OR?:
    | ActivityTypeSubscriptionWhereInput[]
    | ActivityTypeSubscriptionWhereInput;
  NOT?:
    | ActivityTypeSubscriptionWhereInput[]
    | ActivityTypeSubscriptionWhereInput;
}

export interface ActivityAttendanceCreateManyWithoutScheduleInput {
  create?:
    | ActivityAttendanceCreateWithoutScheduleInput[]
    | ActivityAttendanceCreateWithoutScheduleInput;
  connect?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
}

export interface ProvinceUpdateInput {
  name?: String;
  districts?: DistrictUpdateManyWithoutProvinceInput;
}

export interface ActivityAttendanceCreateWithoutScheduleInput {
  member: ProfileCreateOneWithoutAttendancesInput;
  presence: Boolean;
}

export interface MemberTypeCreateInput {
  name: String;
  profiles?: ProfileCreateManyWithoutMemberTypeInput;
}

export interface ActivityScheduleUpdateInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  activity?: ActivityTypeUpdateOneRequiredWithoutSchedulesInput;
  attendances?: ActivityAttendanceUpdateManyWithoutScheduleInput;
}

export interface ActivityScheduleUpdateManyWithWhereNestedInput {
  where: ActivityScheduleScalarWhereInput;
  data: ActivityScheduleUpdateManyDataInput;
}

export interface ActivityAttendanceUpdateManyWithoutScheduleInput {
  create?:
    | ActivityAttendanceCreateWithoutScheduleInput[]
    | ActivityAttendanceCreateWithoutScheduleInput;
  delete?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  connect?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  set?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  disconnect?:
    | ActivityAttendanceWhereUniqueInput[]
    | ActivityAttendanceWhereUniqueInput;
  update?:
    | ActivityAttendanceUpdateWithWhereUniqueWithoutScheduleInput[]
    | ActivityAttendanceUpdateWithWhereUniqueWithoutScheduleInput;
  upsert?:
    | ActivityAttendanceUpsertWithWhereUniqueWithoutScheduleInput[]
    | ActivityAttendanceUpsertWithWhereUniqueWithoutScheduleInput;
  deleteMany?:
    | ActivityAttendanceScalarWhereInput[]
    | ActivityAttendanceScalarWhereInput;
  updateMany?:
    | ActivityAttendanceUpdateManyWithWhereNestedInput[]
    | ActivityAttendanceUpdateManyWithWhereNestedInput;
}

export interface DistrictCreateWithoutCommunesInput {
  name: String;
  province: ProvinceCreateOneWithoutDistrictsInput;
}

export interface ActivityAttendanceUpdateWithWhereUniqueWithoutScheduleInput {
  where: ActivityAttendanceWhereUniqueInput;
  data: ActivityAttendanceUpdateWithoutScheduleDataInput;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProfileWhereInput;
  AND?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
  OR?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
  NOT?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
}

export interface ActivityAttendanceUpdateWithoutScheduleDataInput {
  member?: ProfileUpdateOneRequiredWithoutAttendancesInput;
  presence?: Boolean;
}

export interface ProfileUpdateWithoutMemberTypeDataInput {
  oldId?: ID_Input;
  firstName?: String;
  lastName?: String;
  gender?: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeInput;
  joinDate?: DateTimeInput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  address?: AddressUpdateOneInput;
  hometown?: ProvinceUpdateOneInput;
  group?: GroupUpdateOneWithoutMembersInput;
  leader?: GroupUpdateOneWithoutLeaderInput;
  attendances?: ActivityAttendanceUpdateManyWithoutMemberInput;
}

export interface ActivityScheduleCreateManyWithoutActivityInput {
  create?:
    | ActivityScheduleCreateWithoutActivityInput[]
    | ActivityScheduleCreateWithoutActivityInput;
  connect?:
    | ActivityScheduleWhereUniqueInput[]
    | ActivityScheduleWhereUniqueInput;
}

export interface ActivityTypeCreateInput {
  name: String;
  schedules?: ActivityScheduleCreateManyWithoutActivityInput;
}

export interface ActivityScheduleUpdateManyMutationInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
}

export interface ActivityAttendanceUpsertWithWhereUniqueWithoutScheduleInput {
  where: ActivityAttendanceWhereUniqueInput;
  update: ActivityAttendanceUpdateWithoutScheduleDataInput;
  create: ActivityAttendanceCreateWithoutScheduleInput;
}

export interface CommuneUpdateManyMutationInput {
  name?: String;
}

export interface ActivityTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  schedules_every?: ActivityScheduleWhereInput;
  schedules_some?: ActivityScheduleWhereInput;
  schedules_none?: ActivityScheduleWhereInput;
  AND?: ActivityTypeWhereInput[] | ActivityTypeWhereInput;
  OR?: ActivityTypeWhereInput[] | ActivityTypeWhereInput;
  NOT?: ActivityTypeWhereInput[] | ActivityTypeWhereInput;
}

export interface ProvinceCreateInput {
  name: String;
  districts?: DistrictCreateManyWithoutProvinceInput;
}

export interface ActivityTypeCreateWithoutSchedulesInput {
  name: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  password: String;
  role: Int;
  active: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Int>;
  active: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface ActivityTypeEdge {
  node: ActivityType;
  cursor: String;
}

export interface ActivityTypeEdgePromise
  extends Promise<ActivityTypeEdge>,
    Fragmentable {
  node: <T = ActivityTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityTypeEdgeSubscription
  extends Promise<AsyncIterator<ActivityTypeEdge>>,
    Fragmentable {
  node: <T = ActivityTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Commune {
  id: ID_Output;
  name: String;
}

export interface CommunePromise extends Promise<Commune>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  district: <T = DistrictPromise>() => T;
}

export interface CommuneSubscription
  extends Promise<AsyncIterator<Commune>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  district: <T = DistrictSubscription>() => T;
}

export interface ActivityTypeConnection {
  pageInfo: PageInfo;
  edges: ActivityTypeEdge[];
}

export interface ActivityTypeConnectionPromise
  extends Promise<ActivityTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityTypeEdge>>() => T;
  aggregate: <T = AggregateActivityTypePromise>() => T;
}

export interface ActivityTypeConnectionSubscription
  extends Promise<AsyncIterator<ActivityTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivityTypeSubscription>() => T;
}

export interface AggregateActivitySchedule {
  count: Int;
}

export interface AggregateActivitySchedulePromise
  extends Promise<AggregateActivitySchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityScheduleSubscription
  extends Promise<AsyncIterator<AggregateActivitySchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ActivityScheduleEdge {
  node: ActivitySchedule;
  cursor: String;
}

export interface ActivityScheduleEdgePromise
  extends Promise<ActivityScheduleEdge>,
    Fragmentable {
  node: <T = ActivitySchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityScheduleEdgeSubscription
  extends Promise<AsyncIterator<ActivityScheduleEdge>>,
    Fragmentable {
  node: <T = ActivityScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityScheduleConnection {
  pageInfo: PageInfo;
  edges: ActivityScheduleEdge[];
}

export interface ActivityScheduleConnectionPromise
  extends Promise<ActivityScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityScheduleEdge>>() => T;
  aggregate: <T = AggregateActivitySchedulePromise>() => T;
}

export interface ActivityScheduleConnectionSubscription
  extends Promise<AsyncIterator<ActivityScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivityScheduleSubscription>() => T;
}

export interface ActivitySchedule {
  id: ID_Output;
  start: DateTimeOutput;
  end: DateTimeOutput;
}

export interface ActivitySchedulePromise
  extends Promise<ActivitySchedule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  activity: <T = ActivityTypePromise>() => T;
  attendances: <T = FragmentableArray<ActivityAttendance>>(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ActivityScheduleSubscription
  extends Promise<AsyncIterator<ActivitySchedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  activity: <T = ActivityTypeSubscription>() => T;
  attendances: <
    T = Promise<AsyncIterator<ActivityAttendanceSubscription>>
  >(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateActivityAttendance {
  count: Int;
}

export interface AggregateActivityAttendancePromise
  extends Promise<AggregateActivityAttendance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityAttendanceSubscription
  extends Promise<AsyncIterator<AggregateActivityAttendance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProvince {
  count: Int;
}

export interface AggregateProvincePromise
  extends Promise<AggregateProvince>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProvinceSubscription
  extends Promise<AsyncIterator<AggregateProvince>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityAttendance {
  id: ID_Output;
  presence: Boolean;
}

export interface ActivityAttendancePromise
  extends Promise<ActivityAttendance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  schedule: <T = ActivitySchedulePromise>() => T;
  member: <T = ProfilePromise>() => T;
  presence: () => Promise<Boolean>;
}

export interface ActivityAttendanceSubscription
  extends Promise<AsyncIterator<ActivityAttendance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  schedule: <T = ActivityScheduleSubscription>() => T;
  member: <T = ProfileSubscription>() => T;
  presence: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProvinceConnection {
  pageInfo: PageInfo;
  edges: ProvinceEdge[];
}

export interface ProvinceConnectionPromise
  extends Promise<ProvinceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProvinceEdge>>() => T;
  aggregate: <T = AggregateProvincePromise>() => T;
}

export interface ProvinceConnectionSubscription
  extends Promise<AsyncIterator<ProvinceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProvinceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProvinceSubscription>() => T;
}

export interface ActivityAttendanceSubscriptionPayload {
  mutation: MutationType;
  node: ActivityAttendance;
  updatedFields: String[];
  previousValues: ActivityAttendancePreviousValues;
}

export interface ActivityAttendanceSubscriptionPayloadPromise
  extends Promise<ActivityAttendanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityAttendancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityAttendancePreviousValuesPromise>() => T;
}

export interface ActivityAttendanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityAttendanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityAttendanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityAttendancePreviousValuesSubscription>() => T;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityAttendancePreviousValues {
  id: ID_Output;
  presence: Boolean;
}

export interface ActivityAttendancePreviousValuesPromise
  extends Promise<ActivityAttendancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  presence: () => Promise<Boolean>;
}

export interface ActivityAttendancePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityAttendancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  presence: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

export interface ActivityAttendanceEdge {
  node: ActivityAttendance;
  cursor: String;
}

export interface ActivityAttendanceEdgePromise
  extends Promise<ActivityAttendanceEdge>,
    Fragmentable {
  node: <T = ActivityAttendancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityAttendanceEdgeSubscription
  extends Promise<AsyncIterator<ActivityAttendanceEdge>>,
    Fragmentable {
  node: <T = ActivityAttendanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MemberTypeEdge {
  node: MemberType;
  cursor: String;
}

export interface MemberTypeEdgePromise
  extends Promise<MemberTypeEdge>,
    Fragmentable {
  node: <T = MemberTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MemberTypeEdgeSubscription
  extends Promise<AsyncIterator<MemberTypeEdge>>,
    Fragmentable {
  node: <T = MemberTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityScheduleSubscriptionPayload {
  mutation: MutationType;
  node: ActivitySchedule;
  updatedFields: String[];
  previousValues: ActivitySchedulePreviousValues;
}

export interface ActivityScheduleSubscriptionPayloadPromise
  extends Promise<ActivityScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivitySchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivitySchedulePreviousValuesPromise>() => T;
}

export interface ActivityScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivitySchedulePreviousValuesSubscription>() => T;
}

export interface ActivityType {
  id: ID_Output;
  name: String;
}

export interface ActivityTypePromise
  extends Promise<ActivityType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  schedules: <T = FragmentableArray<ActivitySchedule>>(args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ActivityTypeSubscription
  extends Promise<AsyncIterator<ActivityType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  schedules: <T = Promise<AsyncIterator<ActivityScheduleSubscription>>>(args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ActivitySchedulePreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  end: DateTimeOutput;
}

export interface ActivitySchedulePreviousValuesPromise
  extends Promise<ActivitySchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface ActivitySchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivitySchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ProvincePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProvincePreviousValuesPromise
  extends Promise<ProvincePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProvincePreviousValuesSubscription
  extends Promise<AsyncIterator<ProvincePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ActivityTypeSubscriptionPayload {
  mutation: MutationType;
  node: ActivityType;
  updatedFields: String[];
  previousValues: ActivityTypePreviousValues;
}

export interface ActivityTypeSubscriptionPayloadPromise
  extends Promise<ActivityTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityTypePreviousValuesPromise>() => T;
}

export interface ActivityTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityTypePreviousValuesSubscription>() => T;
}

export interface DistrictEdge {
  node: District;
  cursor: String;
}

export interface DistrictEdgePromise
  extends Promise<DistrictEdge>,
    Fragmentable {
  node: <T = DistrictPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DistrictEdgeSubscription
  extends Promise<AsyncIterator<DistrictEdge>>,
    Fragmentable {
  node: <T = DistrictSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ActivityTypePreviousValuesPromise
  extends Promise<ActivityTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ActivityTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommune {
  count: Int;
}

export interface AggregateCommunePromise
  extends Promise<AggregateCommune>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommuneSubscription
  extends Promise<AsyncIterator<AggregateCommune>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityAttendanceConnection {
  pageInfo: PageInfo;
  edges: ActivityAttendanceEdge[];
}

export interface ActivityAttendanceConnectionPromise
  extends Promise<ActivityAttendanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityAttendanceEdge>>() => T;
  aggregate: <T = AggregateActivityAttendancePromise>() => T;
}

export interface ActivityAttendanceConnectionSubscription
  extends Promise<AsyncIterator<ActivityAttendanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ActivityAttendanceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateActivityAttendanceSubscription>() => T;
}

export interface CommuneConnection {
  pageInfo: PageInfo;
  edges: CommuneEdge[];
}

export interface CommuneConnectionPromise
  extends Promise<CommuneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommuneEdge>>() => T;
  aggregate: <T = AggregateCommunePromise>() => T;
}

export interface CommuneConnectionSubscription
  extends Promise<AsyncIterator<CommuneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommuneEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommuneSubscription>() => T;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressPreviousValues {
  id: ID_Output;
  no?: String;
  street?: String;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  no: () => Promise<String>;
  street: () => Promise<String>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  no: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivityType {
  count: Int;
}

export interface AggregateActivityTypePromise
  extends Promise<AggregateActivityType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityTypeSubscription
  extends Promise<AsyncIterator<AggregateActivityType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Group {
  id: ID_Output;
  name: String;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  members: <T = FragmentableArray<Profile>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leader: <T = ProfilePromise>() => T;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  members: <T = Promise<AsyncIterator<ProfileSubscription>>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leader: <T = ProfileSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommuneSubscriptionPayload {
  mutation: MutationType;
  node: Commune;
  updatedFields: String[];
  previousValues: CommunePreviousValues;
}

export interface CommuneSubscriptionPayloadPromise
  extends Promise<CommuneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommunePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommunePreviousValuesPromise>() => T;
}

export interface CommuneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommuneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommuneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommunePreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  username: String;
  password: String;
  role: Int;
  active: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Int>;
  active: () => Promise<Boolean>;
  profile: <T = ProfilePromise>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  profile: <T = ProfileSubscription>() => T;
}

export interface CommunePreviousValues {
  id: ID_Output;
  name: String;
}

export interface CommunePreviousValuesPromise
  extends Promise<CommunePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CommunePreviousValuesSubscription
  extends Promise<AsyncIterator<CommunePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Address {
  id: ID_Output;
  no?: String;
  street?: String;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  no: () => Promise<String>;
  street: () => Promise<String>;
  commune: <T = CommunePromise>() => T;
  district: <T = DistrictPromise>() => T;
  province: <T = ProvincePromise>() => T;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  no: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  commune: <T = CommuneSubscription>() => T;
  district: <T = DistrictSubscription>() => T;
  province: <T = ProvinceSubscription>() => T;
}

export interface MemberType {
  id: ID_Output;
  name: String;
}

export interface MemberTypePromise extends Promise<MemberType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  profiles: <T = FragmentableArray<Profile>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MemberTypeSubscription
  extends Promise<AsyncIterator<MemberType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  profiles: <T = Promise<AsyncIterator<ProfileSubscription>>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateMemberType {
  count: Int;
}

export interface AggregateMemberTypePromise
  extends Promise<AggregateMemberType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMemberTypeSubscription
  extends Promise<AsyncIterator<AggregateMemberType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DistrictSubscriptionPayload {
  mutation: MutationType;
  node: District;
  updatedFields: String[];
  previousValues: DistrictPreviousValues;
}

export interface DistrictSubscriptionPayloadPromise
  extends Promise<DistrictSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DistrictPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DistrictPreviousValuesPromise>() => T;
}

export interface DistrictSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DistrictSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DistrictSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DistrictPreviousValuesSubscription>() => T;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DistrictPreviousValues {
  id: ID_Output;
  name: String;
}

export interface DistrictPreviousValuesPromise
  extends Promise<DistrictPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DistrictPreviousValuesSubscription
  extends Promise<AsyncIterator<DistrictPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDistrict {
  count: Int;
}

export interface AggregateDistrictPromise
  extends Promise<AggregateDistrict>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDistrictSubscription
  extends Promise<AsyncIterator<AggregateDistrict>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Province {
  id: ID_Output;
  name: String;
}

export interface ProvincePromise extends Promise<Province>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  districts: <T = FragmentableArray<District>>(args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProvinceSubscription
  extends Promise<AsyncIterator<Province>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  districts: <T = Promise<AsyncIterator<DistrictSubscription>>>(args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommuneEdge {
  node: Commune;
  cursor: String;
}

export interface CommuneEdgePromise extends Promise<CommuneEdge>, Fragmentable {
  node: <T = CommunePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommuneEdgeSubscription
  extends Promise<AsyncIterator<CommuneEdge>>,
    Fragmentable {
  node: <T = CommuneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface GroupPreviousValues {
  id: ID_Output;
  name: String;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ProvinceSubscriptionPayload {
  mutation: MutationType;
  node: Province;
  updatedFields: String[];
  previousValues: ProvincePreviousValues;
}

export interface ProvinceSubscriptionPayloadPromise
  extends Promise<ProvinceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProvincePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProvincePreviousValuesPromise>() => T;
}

export interface ProvinceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProvinceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProvinceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProvincePreviousValuesSubscription>() => T;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MemberTypeSubscriptionPayload {
  mutation: MutationType;
  node: MemberType;
  updatedFields: String[];
  previousValues: MemberTypePreviousValues;
}

export interface MemberTypeSubscriptionPayloadPromise
  extends Promise<MemberTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MemberTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MemberTypePreviousValuesPromise>() => T;
}

export interface MemberTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MemberTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MemberTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MemberTypePreviousValuesSubscription>() => T;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfilePreviousValues {
  id: ID_Output;
  oldId: ID_Output;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  joinDate?: DateTimeOutput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  oldId: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Boolean>;
  email: () => Promise<String>;
  facebookId: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  joinDate: () => Promise<DateTimeOutput>;
  dayOfBirth: () => Promise<Int>;
  monthOfBirth: () => Promise<Int>;
  yearOfBirth: () => Promise<Int>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  oldId: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  facebookId: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  joinDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dayOfBirth: () => Promise<AsyncIterator<Int>>;
  monthOfBirth: () => Promise<AsyncIterator<Int>>;
  yearOfBirth: () => Promise<AsyncIterator<Int>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface District {
  id: ID_Output;
  name: String;
}

export interface DistrictPromise extends Promise<District>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  communes: <T = FragmentableArray<Commune>>(args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  province: <T = ProvincePromise>() => T;
}

export interface DistrictSubscription
  extends Promise<AsyncIterator<District>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  communes: <T = Promise<AsyncIterator<CommuneSubscription>>>(args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  province: <T = ProvinceSubscription>() => T;
}

export interface MemberTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface MemberTypePreviousValuesPromise
  extends Promise<MemberTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface MemberTypePreviousValuesSubscription
  extends Promise<AsyncIterator<MemberTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Profile {
  id: ID_Output;
  oldId: ID_Output;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  joinDate?: DateTimeOutput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>;
  oldId: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Boolean>;
  email: () => Promise<String>;
  facebookId: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  joinDate: () => Promise<DateTimeOutput>;
  dayOfBirth: () => Promise<Int>;
  monthOfBirth: () => Promise<Int>;
  yearOfBirth: () => Promise<Int>;
  address: <T = AddressPromise>() => T;
  hometown: <T = ProvincePromise>() => T;
  memberType: <T = MemberTypePromise>() => T;
  group: <T = GroupPromise>() => T;
  leader: <T = GroupPromise>() => T;
  attendances: <T = FragmentableArray<ActivityAttendance>>(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  oldId: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  facebookId: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  joinDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dayOfBirth: () => Promise<AsyncIterator<Int>>;
  monthOfBirth: () => Promise<AsyncIterator<Int>>;
  yearOfBirth: () => Promise<AsyncIterator<Int>>;
  address: <T = AddressSubscription>() => T;
  hometown: <T = ProvinceSubscription>() => T;
  memberType: <T = MemberTypeSubscription>() => T;
  group: <T = GroupSubscription>() => T;
  leader: <T = GroupSubscription>() => T;
  attendances: <
    T = Promise<AsyncIterator<ActivityAttendanceSubscription>>
  >(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DistrictConnection {
  pageInfo: PageInfo;
  edges: DistrictEdge[];
}

export interface DistrictConnectionPromise
  extends Promise<DistrictConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DistrictEdge>>() => T;
  aggregate: <T = AggregateDistrictPromise>() => T;
}

export interface DistrictConnectionSubscription
  extends Promise<AsyncIterator<DistrictConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DistrictEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDistrictSubscription>() => T;
}

export interface MemberTypeConnection {
  pageInfo: PageInfo;
  edges: MemberTypeEdge[];
}

export interface MemberTypeConnectionPromise
  extends Promise<MemberTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MemberTypeEdge>>() => T;
  aggregate: <T = AggregateMemberTypePromise>() => T;
}

export interface MemberTypeConnectionSubscription
  extends Promise<AsyncIterator<MemberTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MemberTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMemberTypeSubscription>() => T;
}

export interface ProvinceEdge {
  node: Province;
  cursor: String;
}

export interface ProvinceEdgePromise
  extends Promise<ProvinceEdge>,
    Fragmentable {
  node: <T = ProvincePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProvinceEdgeSubscription
  extends Promise<AsyncIterator<ProvinceEdge>>,
    Fragmentable {
  node: <T = ProvinceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ActivityAttendance",
    embedded: false
  },
  {
    name: "ActivitySchedule",
    embedded: false
  },
  {
    name: "ActivityType",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Commune",
    embedded: false
  },
  {
    name: "District",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "MemberType",
    embedded: false
  },
  {
    name: "Profile",
    embedded: false
  },
  {
    name: "Province",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://prisma.btngiadinh.com/vichurch-btngiadinh/dev`,
  secret: `$(env:PRISMA_MANAGEMENT_API_SECRET)`
});
export const prisma = new Prisma();
