// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  activityAttendance: (
    where?: ActivityAttendanceWhereInput
  ) => Promise<boolean>;
  activitySchedule: (where?: ActivityScheduleWhereInput) => Promise<boolean>;
  activityType: (where?: ActivityTypeWhereInput) => Promise<boolean>;
  address: (where?: AddressWhereInput) => Promise<boolean>;
  commune: (where?: CommuneWhereInput) => Promise<boolean>;
  district: (where?: DistrictWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  memberType: (where?: MemberTypeWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  province: (where?: ProvinceWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activityAttendance: (
    where: ActivityAttendanceWhereUniqueInput
  ) => ActivityAttendanceNullablePromise;
  activityAttendances: (args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivityAttendance>;
  activityAttendancesConnection: (args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityAttendanceConnectionPromise;
  activitySchedule: (
    where: ActivityScheduleWhereUniqueInput
  ) => ActivityScheduleNullablePromise;
  activitySchedules: (args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivitySchedule>;
  activitySchedulesConnection: (args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityScheduleConnectionPromise;
  activityType: (
    where: ActivityTypeWhereUniqueInput
  ) => ActivityTypeNullablePromise;
  activityTypes: (args?: {
    where?: ActivityTypeWhereInput;
    orderBy?: ActivityTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActivityType>;
  activityTypesConnection: (args?: {
    where?: ActivityTypeWhereInput;
    orderBy?: ActivityTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityTypeConnectionPromise;
  address: (where: AddressWhereUniqueInput) => AddressNullablePromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  commune: (where: CommuneWhereUniqueInput) => CommuneNullablePromise;
  communes: (args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Commune>;
  communesConnection: (args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommuneConnectionPromise;
  district: (where: DistrictWhereUniqueInput) => DistrictNullablePromise;
  districts: (args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<District>;
  districtsConnection: (args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DistrictConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupNullablePromise;
  groups: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Group>;
  groupsConnection: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupConnectionPromise;
  memberType: (where: MemberTypeWhereUniqueInput) => MemberTypeNullablePromise;
  memberTypes: (args?: {
    where?: MemberTypeWhereInput;
    orderBy?: MemberTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MemberType>;
  memberTypesConnection: (args?: {
    where?: MemberTypeWhereInput;
    orderBy?: MemberTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MemberTypeConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfileNullablePromise;
  profiles: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Profile>;
  profilesConnection: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProfileConnectionPromise;
  province: (where: ProvinceWhereUniqueInput) => ProvinceNullablePromise;
  provinces: (args?: {
    where?: ProvinceWhereInput;
    orderBy?: ProvinceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Province>;
  provincesConnection: (args?: {
    where?: ProvinceWhereInput;
    orderBy?: ProvinceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProvinceConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivityAttendance: (
    data: ActivityAttendanceCreateInput
  ) => ActivityAttendancePromise;
  updateActivityAttendance: (args: {
    data: ActivityAttendanceUpdateInput;
    where: ActivityAttendanceWhereUniqueInput;
  }) => ActivityAttendancePromise;
  updateManyActivityAttendances: (args: {
    data: ActivityAttendanceUpdateManyMutationInput;
    where?: ActivityAttendanceWhereInput;
  }) => BatchPayloadPromise;
  upsertActivityAttendance: (args: {
    where: ActivityAttendanceWhereUniqueInput;
    create: ActivityAttendanceCreateInput;
    update: ActivityAttendanceUpdateInput;
  }) => ActivityAttendancePromise;
  deleteActivityAttendance: (
    where: ActivityAttendanceWhereUniqueInput
  ) => ActivityAttendancePromise;
  deleteManyActivityAttendances: (
    where?: ActivityAttendanceWhereInput
  ) => BatchPayloadPromise;
  createActivitySchedule: (
    data: ActivityScheduleCreateInput
  ) => ActivitySchedulePromise;
  updateActivitySchedule: (args: {
    data: ActivityScheduleUpdateInput;
    where: ActivityScheduleWhereUniqueInput;
  }) => ActivitySchedulePromise;
  updateManyActivitySchedules: (args: {
    data: ActivityScheduleUpdateManyMutationInput;
    where?: ActivityScheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertActivitySchedule: (args: {
    where: ActivityScheduleWhereUniqueInput;
    create: ActivityScheduleCreateInput;
    update: ActivityScheduleUpdateInput;
  }) => ActivitySchedulePromise;
  deleteActivitySchedule: (
    where: ActivityScheduleWhereUniqueInput
  ) => ActivitySchedulePromise;
  deleteManyActivitySchedules: (
    where?: ActivityScheduleWhereInput
  ) => BatchPayloadPromise;
  createActivityType: (data: ActivityTypeCreateInput) => ActivityTypePromise;
  updateActivityType: (args: {
    data: ActivityTypeUpdateInput;
    where: ActivityTypeWhereUniqueInput;
  }) => ActivityTypePromise;
  updateManyActivityTypes: (args: {
    data: ActivityTypeUpdateManyMutationInput;
    where?: ActivityTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertActivityType: (args: {
    where: ActivityTypeWhereUniqueInput;
    create: ActivityTypeCreateInput;
    update: ActivityTypeUpdateInput;
  }) => ActivityTypePromise;
  deleteActivityType: (
    where: ActivityTypeWhereUniqueInput
  ) => ActivityTypePromise;
  deleteManyActivityTypes: (
    where?: ActivityTypeWhereInput
  ) => BatchPayloadPromise;
  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createCommune: (data: CommuneCreateInput) => CommunePromise;
  updateCommune: (args: {
    data: CommuneUpdateInput;
    where: CommuneWhereUniqueInput;
  }) => CommunePromise;
  updateManyCommunes: (args: {
    data: CommuneUpdateManyMutationInput;
    where?: CommuneWhereInput;
  }) => BatchPayloadPromise;
  upsertCommune: (args: {
    where: CommuneWhereUniqueInput;
    create: CommuneCreateInput;
    update: CommuneUpdateInput;
  }) => CommunePromise;
  deleteCommune: (where: CommuneWhereUniqueInput) => CommunePromise;
  deleteManyCommunes: (where?: CommuneWhereInput) => BatchPayloadPromise;
  createDistrict: (data: DistrictCreateInput) => DistrictPromise;
  updateDistrict: (args: {
    data: DistrictUpdateInput;
    where: DistrictWhereUniqueInput;
  }) => DistrictPromise;
  updateManyDistricts: (args: {
    data: DistrictUpdateManyMutationInput;
    where?: DistrictWhereInput;
  }) => BatchPayloadPromise;
  upsertDistrict: (args: {
    where: DistrictWhereUniqueInput;
    create: DistrictCreateInput;
    update: DistrictUpdateInput;
  }) => DistrictPromise;
  deleteDistrict: (where: DistrictWhereUniqueInput) => DistrictPromise;
  deleteManyDistricts: (where?: DistrictWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (args: {
    data: GroupUpdateInput;
    where: GroupWhereUniqueInput;
  }) => GroupPromise;
  updateManyGroups: (args: {
    data: GroupUpdateManyMutationInput;
    where?: GroupWhereInput;
  }) => BatchPayloadPromise;
  upsertGroup: (args: {
    where: GroupWhereUniqueInput;
    create: GroupCreateInput;
    update: GroupUpdateInput;
  }) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createMemberType: (data: MemberTypeCreateInput) => MemberTypePromise;
  updateMemberType: (args: {
    data: MemberTypeUpdateInput;
    where: MemberTypeWhereUniqueInput;
  }) => MemberTypePromise;
  updateManyMemberTypes: (args: {
    data: MemberTypeUpdateManyMutationInput;
    where?: MemberTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertMemberType: (args: {
    where: MemberTypeWhereUniqueInput;
    create: MemberTypeCreateInput;
    update: MemberTypeUpdateInput;
  }) => MemberTypePromise;
  deleteMemberType: (where: MemberTypeWhereUniqueInput) => MemberTypePromise;
  deleteManyMemberTypes: (where?: MemberTypeWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (args: {
    data: ProfileUpdateInput;
    where: ProfileWhereUniqueInput;
  }) => ProfilePromise;
  updateManyProfiles: (args: {
    data: ProfileUpdateManyMutationInput;
    where?: ProfileWhereInput;
  }) => BatchPayloadPromise;
  upsertProfile: (args: {
    where: ProfileWhereUniqueInput;
    create: ProfileCreateInput;
    update: ProfileUpdateInput;
  }) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createProvince: (data: ProvinceCreateInput) => ProvincePromise;
  updateProvince: (args: {
    data: ProvinceUpdateInput;
    where: ProvinceWhereUniqueInput;
  }) => ProvincePromise;
  updateManyProvinces: (args: {
    data: ProvinceUpdateManyMutationInput;
    where?: ProvinceWhereInput;
  }) => BatchPayloadPromise;
  upsertProvince: (args: {
    where: ProvinceWhereUniqueInput;
    create: ProvinceCreateInput;
    update: ProvinceUpdateInput;
  }) => ProvincePromise;
  deleteProvince: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  deleteManyProvinces: (where?: ProvinceWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activityAttendance: (
    where?: ActivityAttendanceSubscriptionWhereInput
  ) => ActivityAttendanceSubscriptionPayloadSubscription;
  activitySchedule: (
    where?: ActivityScheduleSubscriptionWhereInput
  ) => ActivityScheduleSubscriptionPayloadSubscription;
  activityType: (
    where?: ActivityTypeSubscriptionWhereInput
  ) => ActivityTypeSubscriptionPayloadSubscription;
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  commune: (
    where?: CommuneSubscriptionWhereInput
  ) => CommuneSubscriptionPayloadSubscription;
  district: (
    where?: DistrictSubscriptionWhereInput
  ) => DistrictSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  memberType: (
    where?: MemberTypeSubscriptionWhereInput
  ) => MemberTypeSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  province: (
    where?: ProvinceSubscriptionWhereInput
  ) => ProvinceSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ActivityScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ActivityAttendanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "presence_ASC"
  | "presence_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CommuneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type DistrictOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "oldId_ASC"
  | "oldId_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "email_ASC"
  | "email_DESC"
  | "facebookId_ASC"
  | "facebookId_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "joinDate_ASC"
  | "joinDate_DESC"
  | "dayOfBirth_ASC"
  | "dayOfBirth_DESC"
  | "monthOfBirth_ASC"
  | "monthOfBirth_DESC"
  | "yearOfBirth_ASC"
  | "yearOfBirth_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ActivityTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "no_ASC"
  | "no_DESC"
  | "street_ASC"
  | "street_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MemberTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ProvinceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "active_ASC"
  | "active_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActivityAttendanceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ActivityScheduleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<DateTimeInput>;
  start_not?: Maybe<DateTimeInput>;
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_lt?: Maybe<DateTimeInput>;
  start_lte?: Maybe<DateTimeInput>;
  start_gt?: Maybe<DateTimeInput>;
  start_gte?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  end_not?: Maybe<DateTimeInput>;
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_lt?: Maybe<DateTimeInput>;
  end_lte?: Maybe<DateTimeInput>;
  end_gt?: Maybe<DateTimeInput>;
  end_gte?: Maybe<DateTimeInput>;
  activity?: Maybe<ActivityTypeWhereInput>;
  attendances_every?: Maybe<ActivityAttendanceWhereInput>;
  attendances_some?: Maybe<ActivityAttendanceWhereInput>;
  attendances_none?: Maybe<ActivityAttendanceWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActivityScheduleWhereInput[] | ActivityScheduleWhereInput>;
  OR?: Maybe<ActivityScheduleWhereInput[] | ActivityScheduleWhereInput>;
  NOT?: Maybe<ActivityScheduleWhereInput[] | ActivityScheduleWhereInput>;
}

export interface ActivityTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  schedules_every?: Maybe<ActivityScheduleWhereInput>;
  schedules_some?: Maybe<ActivityScheduleWhereInput>;
  schedules_none?: Maybe<ActivityScheduleWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActivityTypeWhereInput[] | ActivityTypeWhereInput>;
  OR?: Maybe<ActivityTypeWhereInput[] | ActivityTypeWhereInput>;
  NOT?: Maybe<ActivityTypeWhereInput[] | ActivityTypeWhereInput>;
}

export interface ActivityAttendanceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  schedule?: Maybe<ActivityScheduleWhereInput>;
  member?: Maybe<ProfileWhereInput>;
  presence?: Maybe<Boolean>;
  presence_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActivityAttendanceWhereInput[] | ActivityAttendanceWhereInput>;
  OR?: Maybe<ActivityAttendanceWhereInput[] | ActivityAttendanceWhereInput>;
  NOT?: Maybe<ActivityAttendanceWhereInput[] | ActivityAttendanceWhereInput>;
}

export interface ProfileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  oldId?: Maybe<ID_Input>;
  oldId_not?: Maybe<ID_Input>;
  oldId_in?: Maybe<ID_Input[] | ID_Input>;
  oldId_not_in?: Maybe<ID_Input[] | ID_Input>;
  oldId_lt?: Maybe<ID_Input>;
  oldId_lte?: Maybe<ID_Input>;
  oldId_gt?: Maybe<ID_Input>;
  oldId_gte?: Maybe<ID_Input>;
  oldId_contains?: Maybe<ID_Input>;
  oldId_not_contains?: Maybe<ID_Input>;
  oldId_starts_with?: Maybe<ID_Input>;
  oldId_not_starts_with?: Maybe<ID_Input>;
  oldId_ends_with?: Maybe<ID_Input>;
  oldId_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Boolean>;
  gender_not?: Maybe<Boolean>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  facebookId?: Maybe<String>;
  facebookId_not?: Maybe<String>;
  facebookId_in?: Maybe<String[] | String>;
  facebookId_not_in?: Maybe<String[] | String>;
  facebookId_lt?: Maybe<String>;
  facebookId_lte?: Maybe<String>;
  facebookId_gt?: Maybe<String>;
  facebookId_gte?: Maybe<String>;
  facebookId_contains?: Maybe<String>;
  facebookId_not_contains?: Maybe<String>;
  facebookId_starts_with?: Maybe<String>;
  facebookId_not_starts_with?: Maybe<String>;
  facebookId_ends_with?: Maybe<String>;
  facebookId_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  joinDate_not?: Maybe<DateTimeInput>;
  joinDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joinDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joinDate_lt?: Maybe<DateTimeInput>;
  joinDate_lte?: Maybe<DateTimeInput>;
  joinDate_gt?: Maybe<DateTimeInput>;
  joinDate_gte?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  dayOfBirth_not?: Maybe<Int>;
  dayOfBirth_in?: Maybe<Int[] | Int>;
  dayOfBirth_not_in?: Maybe<Int[] | Int>;
  dayOfBirth_lt?: Maybe<Int>;
  dayOfBirth_lte?: Maybe<Int>;
  dayOfBirth_gt?: Maybe<Int>;
  dayOfBirth_gte?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  monthOfBirth_not?: Maybe<Int>;
  monthOfBirth_in?: Maybe<Int[] | Int>;
  monthOfBirth_not_in?: Maybe<Int[] | Int>;
  monthOfBirth_lt?: Maybe<Int>;
  monthOfBirth_lte?: Maybe<Int>;
  monthOfBirth_gt?: Maybe<Int>;
  monthOfBirth_gte?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  yearOfBirth_not?: Maybe<Int>;
  yearOfBirth_in?: Maybe<Int[] | Int>;
  yearOfBirth_not_in?: Maybe<Int[] | Int>;
  yearOfBirth_lt?: Maybe<Int>;
  yearOfBirth_lte?: Maybe<Int>;
  yearOfBirth_gt?: Maybe<Int>;
  yearOfBirth_gte?: Maybe<Int>;
  address?: Maybe<AddressWhereInput>;
  hometown?: Maybe<ProvinceWhereInput>;
  memberType?: Maybe<MemberTypeWhereInput>;
  group?: Maybe<GroupWhereInput>;
  leader?: Maybe<GroupWhereInput>;
  attendances_every?: Maybe<ActivityAttendanceWhereInput>;
  attendances_some?: Maybe<ActivityAttendanceWhereInput>;
  attendances_none?: Maybe<ActivityAttendanceWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  OR?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  NOT?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  no?: Maybe<String>;
  no_not?: Maybe<String>;
  no_in?: Maybe<String[] | String>;
  no_not_in?: Maybe<String[] | String>;
  no_lt?: Maybe<String>;
  no_lte?: Maybe<String>;
  no_gt?: Maybe<String>;
  no_gte?: Maybe<String>;
  no_contains?: Maybe<String>;
  no_not_contains?: Maybe<String>;
  no_starts_with?: Maybe<String>;
  no_not_starts_with?: Maybe<String>;
  no_ends_with?: Maybe<String>;
  no_not_ends_with?: Maybe<String>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  commune?: Maybe<CommuneWhereInput>;
  district?: Maybe<DistrictWhereInput>;
  province?: Maybe<ProvinceWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  OR?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  NOT?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface CommuneWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  district?: Maybe<DistrictWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommuneWhereInput[] | CommuneWhereInput>;
  OR?: Maybe<CommuneWhereInput[] | CommuneWhereInput>;
  NOT?: Maybe<CommuneWhereInput[] | CommuneWhereInput>;
}

export interface DistrictWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  communes_every?: Maybe<CommuneWhereInput>;
  communes_some?: Maybe<CommuneWhereInput>;
  communes_none?: Maybe<CommuneWhereInput>;
  province?: Maybe<ProvinceWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DistrictWhereInput[] | DistrictWhereInput>;
  OR?: Maybe<DistrictWhereInput[] | DistrictWhereInput>;
  NOT?: Maybe<DistrictWhereInput[] | DistrictWhereInput>;
}

export interface ProvinceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  districts_every?: Maybe<DistrictWhereInput>;
  districts_some?: Maybe<DistrictWhereInput>;
  districts_none?: Maybe<DistrictWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProvinceWhereInput[] | ProvinceWhereInput>;
  OR?: Maybe<ProvinceWhereInput[] | ProvinceWhereInput>;
  NOT?: Maybe<ProvinceWhereInput[] | ProvinceWhereInput>;
}

export interface MemberTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  profiles_every?: Maybe<ProfileWhereInput>;
  profiles_some?: Maybe<ProfileWhereInput>;
  profiles_none?: Maybe<ProfileWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MemberTypeWhereInput[] | MemberTypeWhereInput>;
  OR?: Maybe<MemberTypeWhereInput[] | MemberTypeWhereInput>;
  NOT?: Maybe<MemberTypeWhereInput[] | MemberTypeWhereInput>;
}

export interface GroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  members_every?: Maybe<ProfileWhereInput>;
  members_some?: Maybe<ProfileWhereInput>;
  members_none?: Maybe<ProfileWhereInput>;
  leader?: Maybe<ProfileWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GroupWhereInput[] | GroupWhereInput>;
  OR?: Maybe<GroupWhereInput[] | GroupWhereInput>;
  NOT?: Maybe<GroupWhereInput[] | GroupWhereInput>;
}

export type ActivityScheduleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ActivityTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CommuneWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type DistrictWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MemberTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  oldId?: Maybe<ID_Input>;
}>;

export type ProvinceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Int>;
  role_not?: Maybe<Int>;
  role_in?: Maybe<Int[] | Int>;
  role_not_in?: Maybe<Int[] | Int>;
  role_lt?: Maybe<Int>;
  role_lte?: Maybe<Int>;
  role_gt?: Maybe<Int>;
  role_gte?: Maybe<Int>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  profile?: Maybe<ProfileWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ActivityAttendanceCreateInput {
  id?: Maybe<ID_Input>;
  schedule: ActivityScheduleCreateOneWithoutAttendancesInput;
  member: ProfileCreateOneWithoutAttendancesInput;
  presence: Boolean;
}

export interface ActivityScheduleCreateOneWithoutAttendancesInput {
  create?: Maybe<ActivityScheduleCreateWithoutAttendancesInput>;
  connect?: Maybe<ActivityScheduleWhereUniqueInput>;
}

export interface ActivityScheduleCreateWithoutAttendancesInput {
  id?: Maybe<ID_Input>;
  start: DateTimeInput;
  end: DateTimeInput;
  activity: ActivityTypeCreateOneWithoutSchedulesInput;
}

export interface ActivityTypeCreateOneWithoutSchedulesInput {
  create?: Maybe<ActivityTypeCreateWithoutSchedulesInput>;
  connect?: Maybe<ActivityTypeWhereUniqueInput>;
}

export interface ActivityTypeCreateWithoutSchedulesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ProfileCreateOneWithoutAttendancesInput {
  create?: Maybe<ProfileCreateWithoutAttendancesInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileCreateWithoutAttendancesInput {
  id?: Maybe<ID_Input>;
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressCreateOneInput>;
  hometown?: Maybe<ProvinceCreateOneInput>;
  memberType?: Maybe<MemberTypeCreateOneWithoutProfilesInput>;
  group?: Maybe<GroupCreateOneWithoutMembersInput>;
  leader?: Maybe<GroupCreateOneWithoutLeaderInput>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  no?: Maybe<String>;
  street?: Maybe<String>;
  commune?: Maybe<CommuneCreateOneInput>;
  district?: Maybe<DistrictCreateOneInput>;
  province?: Maybe<ProvinceCreateOneInput>;
}

export interface CommuneCreateOneInput {
  create?: Maybe<CommuneCreateInput>;
  connect?: Maybe<CommuneWhereUniqueInput>;
}

export interface CommuneCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  district: DistrictCreateOneWithoutCommunesInput;
}

export interface DistrictCreateOneWithoutCommunesInput {
  create?: Maybe<DistrictCreateWithoutCommunesInput>;
  connect?: Maybe<DistrictWhereUniqueInput>;
}

export interface DistrictCreateWithoutCommunesInput {
  id?: Maybe<ID_Input>;
  name: String;
  province: ProvinceCreateOneWithoutDistrictsInput;
}

export interface ProvinceCreateOneWithoutDistrictsInput {
  create?: Maybe<ProvinceCreateWithoutDistrictsInput>;
  connect?: Maybe<ProvinceWhereUniqueInput>;
}

export interface ProvinceCreateWithoutDistrictsInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface DistrictCreateOneInput {
  create?: Maybe<DistrictCreateInput>;
  connect?: Maybe<DistrictWhereUniqueInput>;
}

export interface DistrictCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  communes?: Maybe<CommuneCreateManyWithoutDistrictInput>;
  province: ProvinceCreateOneWithoutDistrictsInput;
}

export interface CommuneCreateManyWithoutDistrictInput {
  create?: Maybe<
    CommuneCreateWithoutDistrictInput[] | CommuneCreateWithoutDistrictInput
  >;
  connect?: Maybe<CommuneWhereUniqueInput[] | CommuneWhereUniqueInput>;
}

export interface CommuneCreateWithoutDistrictInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ProvinceCreateOneInput {
  create?: Maybe<ProvinceCreateInput>;
  connect?: Maybe<ProvinceWhereUniqueInput>;
}

export interface ProvinceCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  districts?: Maybe<DistrictCreateManyWithoutProvinceInput>;
}

export interface DistrictCreateManyWithoutProvinceInput {
  create?: Maybe<
    DistrictCreateWithoutProvinceInput[] | DistrictCreateWithoutProvinceInput
  >;
  connect?: Maybe<DistrictWhereUniqueInput[] | DistrictWhereUniqueInput>;
}

export interface DistrictCreateWithoutProvinceInput {
  id?: Maybe<ID_Input>;
  name: String;
  communes?: Maybe<CommuneCreateManyWithoutDistrictInput>;
}

export interface MemberTypeCreateOneWithoutProfilesInput {
  create?: Maybe<MemberTypeCreateWithoutProfilesInput>;
  connect?: Maybe<MemberTypeWhereUniqueInput>;
}

export interface MemberTypeCreateWithoutProfilesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface GroupCreateOneWithoutMembersInput {
  create?: Maybe<GroupCreateWithoutMembersInput>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  leader?: Maybe<ProfileCreateOneWithoutLeaderInput>;
}

export interface ProfileCreateOneWithoutLeaderInput {
  create?: Maybe<ProfileCreateWithoutLeaderInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileCreateWithoutLeaderInput {
  id?: Maybe<ID_Input>;
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressCreateOneInput>;
  hometown?: Maybe<ProvinceCreateOneInput>;
  memberType?: Maybe<MemberTypeCreateOneWithoutProfilesInput>;
  group?: Maybe<GroupCreateOneWithoutMembersInput>;
  attendances?: Maybe<ActivityAttendanceCreateManyWithoutMemberInput>;
}

export interface ActivityAttendanceCreateManyWithoutMemberInput {
  create?: Maybe<
    | ActivityAttendanceCreateWithoutMemberInput[]
    | ActivityAttendanceCreateWithoutMemberInput
  >;
  connect?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
}

export interface ActivityAttendanceCreateWithoutMemberInput {
  id?: Maybe<ID_Input>;
  schedule: ActivityScheduleCreateOneWithoutAttendancesInput;
  presence: Boolean;
}

export interface GroupCreateOneWithoutLeaderInput {
  create?: Maybe<GroupCreateWithoutLeaderInput>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupCreateWithoutLeaderInput {
  id?: Maybe<ID_Input>;
  name: String;
  members?: Maybe<ProfileCreateManyWithoutGroupInput>;
}

export interface ProfileCreateManyWithoutGroupInput {
  create?: Maybe<
    ProfileCreateWithoutGroupInput[] | ProfileCreateWithoutGroupInput
  >;
  connect?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
}

export interface ProfileCreateWithoutGroupInput {
  id?: Maybe<ID_Input>;
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressCreateOneInput>;
  hometown?: Maybe<ProvinceCreateOneInput>;
  memberType?: Maybe<MemberTypeCreateOneWithoutProfilesInput>;
  leader?: Maybe<GroupCreateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceCreateManyWithoutMemberInput>;
}

export interface ActivityAttendanceUpdateInput {
  schedule?: Maybe<ActivityScheduleUpdateOneRequiredWithoutAttendancesInput>;
  member?: Maybe<ProfileUpdateOneRequiredWithoutAttendancesInput>;
  presence?: Maybe<Boolean>;
}

export interface ActivityScheduleUpdateOneRequiredWithoutAttendancesInput {
  create?: Maybe<ActivityScheduleCreateWithoutAttendancesInput>;
  update?: Maybe<ActivityScheduleUpdateWithoutAttendancesDataInput>;
  upsert?: Maybe<ActivityScheduleUpsertWithoutAttendancesInput>;
  connect?: Maybe<ActivityScheduleWhereUniqueInput>;
}

export interface ActivityScheduleUpdateWithoutAttendancesDataInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  activity?: Maybe<ActivityTypeUpdateOneRequiredWithoutSchedulesInput>;
}

export interface ActivityTypeUpdateOneRequiredWithoutSchedulesInput {
  create?: Maybe<ActivityTypeCreateWithoutSchedulesInput>;
  update?: Maybe<ActivityTypeUpdateWithoutSchedulesDataInput>;
  upsert?: Maybe<ActivityTypeUpsertWithoutSchedulesInput>;
  connect?: Maybe<ActivityTypeWhereUniqueInput>;
}

export interface ActivityTypeUpdateWithoutSchedulesDataInput {
  name?: Maybe<String>;
}

export interface ActivityTypeUpsertWithoutSchedulesInput {
  update: ActivityTypeUpdateWithoutSchedulesDataInput;
  create: ActivityTypeCreateWithoutSchedulesInput;
}

export interface ActivityScheduleUpsertWithoutAttendancesInput {
  update: ActivityScheduleUpdateWithoutAttendancesDataInput;
  create: ActivityScheduleCreateWithoutAttendancesInput;
}

export interface ProfileUpdateOneRequiredWithoutAttendancesInput {
  create?: Maybe<ProfileCreateWithoutAttendancesInput>;
  update?: Maybe<ProfileUpdateWithoutAttendancesDataInput>;
  upsert?: Maybe<ProfileUpsertWithoutAttendancesInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileUpdateWithoutAttendancesDataInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressUpdateOneInput>;
  hometown?: Maybe<ProvinceUpdateOneInput>;
  memberType?: Maybe<MemberTypeUpdateOneWithoutProfilesInput>;
  group?: Maybe<GroupUpdateOneWithoutMembersInput>;
  leader?: Maybe<GroupUpdateOneWithoutLeaderInput>;
}

export interface AddressUpdateOneInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface AddressUpdateDataInput {
  no?: Maybe<String>;
  street?: Maybe<String>;
  commune?: Maybe<CommuneUpdateOneInput>;
  district?: Maybe<DistrictUpdateOneInput>;
  province?: Maybe<ProvinceUpdateOneInput>;
}

export interface CommuneUpdateOneInput {
  create?: Maybe<CommuneCreateInput>;
  update?: Maybe<CommuneUpdateDataInput>;
  upsert?: Maybe<CommuneUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CommuneWhereUniqueInput>;
}

export interface CommuneUpdateDataInput {
  name?: Maybe<String>;
  district?: Maybe<DistrictUpdateOneRequiredWithoutCommunesInput>;
}

export interface DistrictUpdateOneRequiredWithoutCommunesInput {
  create?: Maybe<DistrictCreateWithoutCommunesInput>;
  update?: Maybe<DistrictUpdateWithoutCommunesDataInput>;
  upsert?: Maybe<DistrictUpsertWithoutCommunesInput>;
  connect?: Maybe<DistrictWhereUniqueInput>;
}

export interface DistrictUpdateWithoutCommunesDataInput {
  name?: Maybe<String>;
  province?: Maybe<ProvinceUpdateOneRequiredWithoutDistrictsInput>;
}

export interface ProvinceUpdateOneRequiredWithoutDistrictsInput {
  create?: Maybe<ProvinceCreateWithoutDistrictsInput>;
  update?: Maybe<ProvinceUpdateWithoutDistrictsDataInput>;
  upsert?: Maybe<ProvinceUpsertWithoutDistrictsInput>;
  connect?: Maybe<ProvinceWhereUniqueInput>;
}

export interface ProvinceUpdateWithoutDistrictsDataInput {
  name?: Maybe<String>;
}

export interface ProvinceUpsertWithoutDistrictsInput {
  update: ProvinceUpdateWithoutDistrictsDataInput;
  create: ProvinceCreateWithoutDistrictsInput;
}

export interface DistrictUpsertWithoutCommunesInput {
  update: DistrictUpdateWithoutCommunesDataInput;
  create: DistrictCreateWithoutCommunesInput;
}

export interface CommuneUpsertNestedInput {
  update: CommuneUpdateDataInput;
  create: CommuneCreateInput;
}

export interface DistrictUpdateOneInput {
  create?: Maybe<DistrictCreateInput>;
  update?: Maybe<DistrictUpdateDataInput>;
  upsert?: Maybe<DistrictUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DistrictWhereUniqueInput>;
}

export interface DistrictUpdateDataInput {
  name?: Maybe<String>;
  communes?: Maybe<CommuneUpdateManyWithoutDistrictInput>;
  province?: Maybe<ProvinceUpdateOneRequiredWithoutDistrictsInput>;
}

export interface CommuneUpdateManyWithoutDistrictInput {
  create?: Maybe<
    CommuneCreateWithoutDistrictInput[] | CommuneCreateWithoutDistrictInput
  >;
  delete?: Maybe<CommuneWhereUniqueInput[] | CommuneWhereUniqueInput>;
  connect?: Maybe<CommuneWhereUniqueInput[] | CommuneWhereUniqueInput>;
  set?: Maybe<CommuneWhereUniqueInput[] | CommuneWhereUniqueInput>;
  disconnect?: Maybe<CommuneWhereUniqueInput[] | CommuneWhereUniqueInput>;
  update?: Maybe<
    | CommuneUpdateWithWhereUniqueWithoutDistrictInput[]
    | CommuneUpdateWithWhereUniqueWithoutDistrictInput
  >;
  upsert?: Maybe<
    | CommuneUpsertWithWhereUniqueWithoutDistrictInput[]
    | CommuneUpsertWithWhereUniqueWithoutDistrictInput
  >;
  deleteMany?: Maybe<CommuneScalarWhereInput[] | CommuneScalarWhereInput>;
  updateMany?: Maybe<
    | CommuneUpdateManyWithWhereNestedInput[]
    | CommuneUpdateManyWithWhereNestedInput
  >;
}

export interface CommuneUpdateWithWhereUniqueWithoutDistrictInput {
  where: CommuneWhereUniqueInput;
  data: CommuneUpdateWithoutDistrictDataInput;
}

export interface CommuneUpdateWithoutDistrictDataInput {
  name?: Maybe<String>;
}

export interface CommuneUpsertWithWhereUniqueWithoutDistrictInput {
  where: CommuneWhereUniqueInput;
  update: CommuneUpdateWithoutDistrictDataInput;
  create: CommuneCreateWithoutDistrictInput;
}

export interface CommuneScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommuneScalarWhereInput[] | CommuneScalarWhereInput>;
  OR?: Maybe<CommuneScalarWhereInput[] | CommuneScalarWhereInput>;
  NOT?: Maybe<CommuneScalarWhereInput[] | CommuneScalarWhereInput>;
}

export interface CommuneUpdateManyWithWhereNestedInput {
  where: CommuneScalarWhereInput;
  data: CommuneUpdateManyDataInput;
}

export interface CommuneUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface DistrictUpsertNestedInput {
  update: DistrictUpdateDataInput;
  create: DistrictCreateInput;
}

export interface ProvinceUpdateOneInput {
  create?: Maybe<ProvinceCreateInput>;
  update?: Maybe<ProvinceUpdateDataInput>;
  upsert?: Maybe<ProvinceUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProvinceWhereUniqueInput>;
}

export interface ProvinceUpdateDataInput {
  name?: Maybe<String>;
  districts?: Maybe<DistrictUpdateManyWithoutProvinceInput>;
}

export interface DistrictUpdateManyWithoutProvinceInput {
  create?: Maybe<
    DistrictCreateWithoutProvinceInput[] | DistrictCreateWithoutProvinceInput
  >;
  delete?: Maybe<DistrictWhereUniqueInput[] | DistrictWhereUniqueInput>;
  connect?: Maybe<DistrictWhereUniqueInput[] | DistrictWhereUniqueInput>;
  set?: Maybe<DistrictWhereUniqueInput[] | DistrictWhereUniqueInput>;
  disconnect?: Maybe<DistrictWhereUniqueInput[] | DistrictWhereUniqueInput>;
  update?: Maybe<
    | DistrictUpdateWithWhereUniqueWithoutProvinceInput[]
    | DistrictUpdateWithWhereUniqueWithoutProvinceInput
  >;
  upsert?: Maybe<
    | DistrictUpsertWithWhereUniqueWithoutProvinceInput[]
    | DistrictUpsertWithWhereUniqueWithoutProvinceInput
  >;
  deleteMany?: Maybe<DistrictScalarWhereInput[] | DistrictScalarWhereInput>;
  updateMany?: Maybe<
    | DistrictUpdateManyWithWhereNestedInput[]
    | DistrictUpdateManyWithWhereNestedInput
  >;
}

export interface DistrictUpdateWithWhereUniqueWithoutProvinceInput {
  where: DistrictWhereUniqueInput;
  data: DistrictUpdateWithoutProvinceDataInput;
}

export interface DistrictUpdateWithoutProvinceDataInput {
  name?: Maybe<String>;
  communes?: Maybe<CommuneUpdateManyWithoutDistrictInput>;
}

export interface DistrictUpsertWithWhereUniqueWithoutProvinceInput {
  where: DistrictWhereUniqueInput;
  update: DistrictUpdateWithoutProvinceDataInput;
  create: DistrictCreateWithoutProvinceInput;
}

export interface DistrictScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DistrictScalarWhereInput[] | DistrictScalarWhereInput>;
  OR?: Maybe<DistrictScalarWhereInput[] | DistrictScalarWhereInput>;
  NOT?: Maybe<DistrictScalarWhereInput[] | DistrictScalarWhereInput>;
}

export interface DistrictUpdateManyWithWhereNestedInput {
  where: DistrictScalarWhereInput;
  data: DistrictUpdateManyDataInput;
}

export interface DistrictUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ProvinceUpsertNestedInput {
  update: ProvinceUpdateDataInput;
  create: ProvinceCreateInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface MemberTypeUpdateOneWithoutProfilesInput {
  create?: Maybe<MemberTypeCreateWithoutProfilesInput>;
  update?: Maybe<MemberTypeUpdateWithoutProfilesDataInput>;
  upsert?: Maybe<MemberTypeUpsertWithoutProfilesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MemberTypeWhereUniqueInput>;
}

export interface MemberTypeUpdateWithoutProfilesDataInput {
  name?: Maybe<String>;
}

export interface MemberTypeUpsertWithoutProfilesInput {
  update: MemberTypeUpdateWithoutProfilesDataInput;
  create: MemberTypeCreateWithoutProfilesInput;
}

export interface GroupUpdateOneWithoutMembersInput {
  create?: Maybe<GroupCreateWithoutMembersInput>;
  update?: Maybe<GroupUpdateWithoutMembersDataInput>;
  upsert?: Maybe<GroupUpsertWithoutMembersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  leader?: Maybe<ProfileUpdateOneWithoutLeaderInput>;
}

export interface ProfileUpdateOneWithoutLeaderInput {
  create?: Maybe<ProfileCreateWithoutLeaderInput>;
  update?: Maybe<ProfileUpdateWithoutLeaderDataInput>;
  upsert?: Maybe<ProfileUpsertWithoutLeaderInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileUpdateWithoutLeaderDataInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressUpdateOneInput>;
  hometown?: Maybe<ProvinceUpdateOneInput>;
  memberType?: Maybe<MemberTypeUpdateOneWithoutProfilesInput>;
  group?: Maybe<GroupUpdateOneWithoutMembersInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutMemberInput>;
}

export interface ActivityAttendanceUpdateManyWithoutMemberInput {
  create?: Maybe<
    | ActivityAttendanceCreateWithoutMemberInput[]
    | ActivityAttendanceCreateWithoutMemberInput
  >;
  delete?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  connect?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  set?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  disconnect?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  update?: Maybe<
    | ActivityAttendanceUpdateWithWhereUniqueWithoutMemberInput[]
    | ActivityAttendanceUpdateWithWhereUniqueWithoutMemberInput
  >;
  upsert?: Maybe<
    | ActivityAttendanceUpsertWithWhereUniqueWithoutMemberInput[]
    | ActivityAttendanceUpsertWithWhereUniqueWithoutMemberInput
  >;
  deleteMany?: Maybe<
    ActivityAttendanceScalarWhereInput[] | ActivityAttendanceScalarWhereInput
  >;
  updateMany?: Maybe<
    | ActivityAttendanceUpdateManyWithWhereNestedInput[]
    | ActivityAttendanceUpdateManyWithWhereNestedInput
  >;
}

export interface ActivityAttendanceUpdateWithWhereUniqueWithoutMemberInput {
  where: ActivityAttendanceWhereUniqueInput;
  data: ActivityAttendanceUpdateWithoutMemberDataInput;
}

export interface ActivityAttendanceUpdateWithoutMemberDataInput {
  schedule?: Maybe<ActivityScheduleUpdateOneRequiredWithoutAttendancesInput>;
  presence?: Maybe<Boolean>;
}

export interface ActivityAttendanceUpsertWithWhereUniqueWithoutMemberInput {
  where: ActivityAttendanceWhereUniqueInput;
  update: ActivityAttendanceUpdateWithoutMemberDataInput;
  create: ActivityAttendanceCreateWithoutMemberInput;
}

export interface ActivityAttendanceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  presence?: Maybe<Boolean>;
  presence_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ActivityAttendanceScalarWhereInput[] | ActivityAttendanceScalarWhereInput
  >;
  OR?: Maybe<
    ActivityAttendanceScalarWhereInput[] | ActivityAttendanceScalarWhereInput
  >;
  NOT?: Maybe<
    ActivityAttendanceScalarWhereInput[] | ActivityAttendanceScalarWhereInput
  >;
}

export interface ActivityAttendanceUpdateManyWithWhereNestedInput {
  where: ActivityAttendanceScalarWhereInput;
  data: ActivityAttendanceUpdateManyDataInput;
}

export interface ActivityAttendanceUpdateManyDataInput {
  presence?: Maybe<Boolean>;
}

export interface ProfileUpsertWithoutLeaderInput {
  update: ProfileUpdateWithoutLeaderDataInput;
  create: ProfileCreateWithoutLeaderInput;
}

export interface GroupUpsertWithoutMembersInput {
  update: GroupUpdateWithoutMembersDataInput;
  create: GroupCreateWithoutMembersInput;
}

export interface GroupUpdateOneWithoutLeaderInput {
  create?: Maybe<GroupCreateWithoutLeaderInput>;
  update?: Maybe<GroupUpdateWithoutLeaderDataInput>;
  upsert?: Maybe<GroupUpsertWithoutLeaderInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupUpdateWithoutLeaderDataInput {
  name?: Maybe<String>;
  members?: Maybe<ProfileUpdateManyWithoutGroupInput>;
}

export interface ProfileUpdateManyWithoutGroupInput {
  create?: Maybe<
    ProfileCreateWithoutGroupInput[] | ProfileCreateWithoutGroupInput
  >;
  delete?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  connect?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  set?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  disconnect?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  update?: Maybe<
    | ProfileUpdateWithWhereUniqueWithoutGroupInput[]
    | ProfileUpdateWithWhereUniqueWithoutGroupInput
  >;
  upsert?: Maybe<
    | ProfileUpsertWithWhereUniqueWithoutGroupInput[]
    | ProfileUpsertWithWhereUniqueWithoutGroupInput
  >;
  deleteMany?: Maybe<ProfileScalarWhereInput[] | ProfileScalarWhereInput>;
  updateMany?: Maybe<
    | ProfileUpdateManyWithWhereNestedInput[]
    | ProfileUpdateManyWithWhereNestedInput
  >;
}

export interface ProfileUpdateWithWhereUniqueWithoutGroupInput {
  where: ProfileWhereUniqueInput;
  data: ProfileUpdateWithoutGroupDataInput;
}

export interface ProfileUpdateWithoutGroupDataInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressUpdateOneInput>;
  hometown?: Maybe<ProvinceUpdateOneInput>;
  memberType?: Maybe<MemberTypeUpdateOneWithoutProfilesInput>;
  leader?: Maybe<GroupUpdateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutMemberInput>;
}

export interface ProfileUpsertWithWhereUniqueWithoutGroupInput {
  where: ProfileWhereUniqueInput;
  update: ProfileUpdateWithoutGroupDataInput;
  create: ProfileCreateWithoutGroupInput;
}

export interface ProfileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  oldId?: Maybe<ID_Input>;
  oldId_not?: Maybe<ID_Input>;
  oldId_in?: Maybe<ID_Input[] | ID_Input>;
  oldId_not_in?: Maybe<ID_Input[] | ID_Input>;
  oldId_lt?: Maybe<ID_Input>;
  oldId_lte?: Maybe<ID_Input>;
  oldId_gt?: Maybe<ID_Input>;
  oldId_gte?: Maybe<ID_Input>;
  oldId_contains?: Maybe<ID_Input>;
  oldId_not_contains?: Maybe<ID_Input>;
  oldId_starts_with?: Maybe<ID_Input>;
  oldId_not_starts_with?: Maybe<ID_Input>;
  oldId_ends_with?: Maybe<ID_Input>;
  oldId_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Boolean>;
  gender_not?: Maybe<Boolean>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  facebookId?: Maybe<String>;
  facebookId_not?: Maybe<String>;
  facebookId_in?: Maybe<String[] | String>;
  facebookId_not_in?: Maybe<String[] | String>;
  facebookId_lt?: Maybe<String>;
  facebookId_lte?: Maybe<String>;
  facebookId_gt?: Maybe<String>;
  facebookId_gte?: Maybe<String>;
  facebookId_contains?: Maybe<String>;
  facebookId_not_contains?: Maybe<String>;
  facebookId_starts_with?: Maybe<String>;
  facebookId_not_starts_with?: Maybe<String>;
  facebookId_ends_with?: Maybe<String>;
  facebookId_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  joinDate_not?: Maybe<DateTimeInput>;
  joinDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joinDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joinDate_lt?: Maybe<DateTimeInput>;
  joinDate_lte?: Maybe<DateTimeInput>;
  joinDate_gt?: Maybe<DateTimeInput>;
  joinDate_gte?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  dayOfBirth_not?: Maybe<Int>;
  dayOfBirth_in?: Maybe<Int[] | Int>;
  dayOfBirth_not_in?: Maybe<Int[] | Int>;
  dayOfBirth_lt?: Maybe<Int>;
  dayOfBirth_lte?: Maybe<Int>;
  dayOfBirth_gt?: Maybe<Int>;
  dayOfBirth_gte?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  monthOfBirth_not?: Maybe<Int>;
  monthOfBirth_in?: Maybe<Int[] | Int>;
  monthOfBirth_not_in?: Maybe<Int[] | Int>;
  monthOfBirth_lt?: Maybe<Int>;
  monthOfBirth_lte?: Maybe<Int>;
  monthOfBirth_gt?: Maybe<Int>;
  monthOfBirth_gte?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  yearOfBirth_not?: Maybe<Int>;
  yearOfBirth_in?: Maybe<Int[] | Int>;
  yearOfBirth_not_in?: Maybe<Int[] | Int>;
  yearOfBirth_lt?: Maybe<Int>;
  yearOfBirth_lte?: Maybe<Int>;
  yearOfBirth_gt?: Maybe<Int>;
  yearOfBirth_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProfileScalarWhereInput[] | ProfileScalarWhereInput>;
  OR?: Maybe<ProfileScalarWhereInput[] | ProfileScalarWhereInput>;
  NOT?: Maybe<ProfileScalarWhereInput[] | ProfileScalarWhereInput>;
}

export interface ProfileUpdateManyWithWhereNestedInput {
  where: ProfileScalarWhereInput;
  data: ProfileUpdateManyDataInput;
}

export interface ProfileUpdateManyDataInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
}

export interface GroupUpsertWithoutLeaderInput {
  update: GroupUpdateWithoutLeaderDataInput;
  create: GroupCreateWithoutLeaderInput;
}

export interface ProfileUpsertWithoutAttendancesInput {
  update: ProfileUpdateWithoutAttendancesDataInput;
  create: ProfileCreateWithoutAttendancesInput;
}

export interface ActivityAttendanceUpdateManyMutationInput {
  presence?: Maybe<Boolean>;
}

export interface ActivityScheduleCreateInput {
  id?: Maybe<ID_Input>;
  start: DateTimeInput;
  end: DateTimeInput;
  activity: ActivityTypeCreateOneWithoutSchedulesInput;
  attendances?: Maybe<ActivityAttendanceCreateManyWithoutScheduleInput>;
}

export interface ActivityAttendanceCreateManyWithoutScheduleInput {
  create?: Maybe<
    | ActivityAttendanceCreateWithoutScheduleInput[]
    | ActivityAttendanceCreateWithoutScheduleInput
  >;
  connect?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
}

export interface ActivityAttendanceCreateWithoutScheduleInput {
  id?: Maybe<ID_Input>;
  member: ProfileCreateOneWithoutAttendancesInput;
  presence: Boolean;
}

export interface ActivityScheduleUpdateInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  activity?: Maybe<ActivityTypeUpdateOneRequiredWithoutSchedulesInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutScheduleInput>;
}

export interface ActivityAttendanceUpdateManyWithoutScheduleInput {
  create?: Maybe<
    | ActivityAttendanceCreateWithoutScheduleInput[]
    | ActivityAttendanceCreateWithoutScheduleInput
  >;
  delete?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  connect?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  set?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  disconnect?: Maybe<
    ActivityAttendanceWhereUniqueInput[] | ActivityAttendanceWhereUniqueInput
  >;
  update?: Maybe<
    | ActivityAttendanceUpdateWithWhereUniqueWithoutScheduleInput[]
    | ActivityAttendanceUpdateWithWhereUniqueWithoutScheduleInput
  >;
  upsert?: Maybe<
    | ActivityAttendanceUpsertWithWhereUniqueWithoutScheduleInput[]
    | ActivityAttendanceUpsertWithWhereUniqueWithoutScheduleInput
  >;
  deleteMany?: Maybe<
    ActivityAttendanceScalarWhereInput[] | ActivityAttendanceScalarWhereInput
  >;
  updateMany?: Maybe<
    | ActivityAttendanceUpdateManyWithWhereNestedInput[]
    | ActivityAttendanceUpdateManyWithWhereNestedInput
  >;
}

export interface ActivityAttendanceUpdateWithWhereUniqueWithoutScheduleInput {
  where: ActivityAttendanceWhereUniqueInput;
  data: ActivityAttendanceUpdateWithoutScheduleDataInput;
}

export interface ActivityAttendanceUpdateWithoutScheduleDataInput {
  member?: Maybe<ProfileUpdateOneRequiredWithoutAttendancesInput>;
  presence?: Maybe<Boolean>;
}

export interface ActivityAttendanceUpsertWithWhereUniqueWithoutScheduleInput {
  where: ActivityAttendanceWhereUniqueInput;
  update: ActivityAttendanceUpdateWithoutScheduleDataInput;
  create: ActivityAttendanceCreateWithoutScheduleInput;
}

export interface ActivityScheduleUpdateManyMutationInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
}

export interface ActivityTypeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  schedules?: Maybe<ActivityScheduleCreateManyWithoutActivityInput>;
}

export interface ActivityScheduleCreateManyWithoutActivityInput {
  create?: Maybe<
    | ActivityScheduleCreateWithoutActivityInput[]
    | ActivityScheduleCreateWithoutActivityInput
  >;
  connect?: Maybe<
    ActivityScheduleWhereUniqueInput[] | ActivityScheduleWhereUniqueInput
  >;
}

export interface ActivityScheduleCreateWithoutActivityInput {
  id?: Maybe<ID_Input>;
  start: DateTimeInput;
  end: DateTimeInput;
  attendances?: Maybe<ActivityAttendanceCreateManyWithoutScheduleInput>;
}

export interface ActivityTypeUpdateInput {
  name?: Maybe<String>;
  schedules?: Maybe<ActivityScheduleUpdateManyWithoutActivityInput>;
}

export interface ActivityScheduleUpdateManyWithoutActivityInput {
  create?: Maybe<
    | ActivityScheduleCreateWithoutActivityInput[]
    | ActivityScheduleCreateWithoutActivityInput
  >;
  delete?: Maybe<
    ActivityScheduleWhereUniqueInput[] | ActivityScheduleWhereUniqueInput
  >;
  connect?: Maybe<
    ActivityScheduleWhereUniqueInput[] | ActivityScheduleWhereUniqueInput
  >;
  set?: Maybe<
    ActivityScheduleWhereUniqueInput[] | ActivityScheduleWhereUniqueInput
  >;
  disconnect?: Maybe<
    ActivityScheduleWhereUniqueInput[] | ActivityScheduleWhereUniqueInput
  >;
  update?: Maybe<
    | ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput[]
    | ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput
  >;
  upsert?: Maybe<
    | ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput[]
    | ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput
  >;
  deleteMany?: Maybe<
    ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput
  >;
  updateMany?: Maybe<
    | ActivityScheduleUpdateManyWithWhereNestedInput[]
    | ActivityScheduleUpdateManyWithWhereNestedInput
  >;
}

export interface ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput {
  where: ActivityScheduleWhereUniqueInput;
  data: ActivityScheduleUpdateWithoutActivityDataInput;
}

export interface ActivityScheduleUpdateWithoutActivityDataInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutScheduleInput>;
}

export interface ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput {
  where: ActivityScheduleWhereUniqueInput;
  update: ActivityScheduleUpdateWithoutActivityDataInput;
  create: ActivityScheduleCreateWithoutActivityInput;
}

export interface ActivityScheduleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<DateTimeInput>;
  start_not?: Maybe<DateTimeInput>;
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_lt?: Maybe<DateTimeInput>;
  start_lte?: Maybe<DateTimeInput>;
  start_gt?: Maybe<DateTimeInput>;
  start_gte?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  end_not?: Maybe<DateTimeInput>;
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_lt?: Maybe<DateTimeInput>;
  end_lte?: Maybe<DateTimeInput>;
  end_gt?: Maybe<DateTimeInput>;
  end_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput
  >;
  OR?: Maybe<
    ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput
  >;
  NOT?: Maybe<
    ActivityScheduleScalarWhereInput[] | ActivityScheduleScalarWhereInput
  >;
}

export interface ActivityScheduleUpdateManyWithWhereNestedInput {
  where: ActivityScheduleScalarWhereInput;
  data: ActivityScheduleUpdateManyDataInput;
}

export interface ActivityScheduleUpdateManyDataInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
}

export interface ActivityTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface AddressUpdateInput {
  no?: Maybe<String>;
  street?: Maybe<String>;
  commune?: Maybe<CommuneUpdateOneInput>;
  district?: Maybe<DistrictUpdateOneInput>;
  province?: Maybe<ProvinceUpdateOneInput>;
}

export interface AddressUpdateManyMutationInput {
  no?: Maybe<String>;
  street?: Maybe<String>;
}

export interface CommuneUpdateInput {
  name?: Maybe<String>;
  district?: Maybe<DistrictUpdateOneRequiredWithoutCommunesInput>;
}

export interface CommuneUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface DistrictUpdateInput {
  name?: Maybe<String>;
  communes?: Maybe<CommuneUpdateManyWithoutDistrictInput>;
  province?: Maybe<ProvinceUpdateOneRequiredWithoutDistrictsInput>;
}

export interface DistrictUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface GroupCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  members?: Maybe<ProfileCreateManyWithoutGroupInput>;
  leader?: Maybe<ProfileCreateOneWithoutLeaderInput>;
}

export interface GroupUpdateInput {
  name?: Maybe<String>;
  members?: Maybe<ProfileUpdateManyWithoutGroupInput>;
  leader?: Maybe<ProfileUpdateOneWithoutLeaderInput>;
}

export interface GroupUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface MemberTypeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  profiles?: Maybe<ProfileCreateManyWithoutMemberTypeInput>;
}

export interface ProfileCreateManyWithoutMemberTypeInput {
  create?: Maybe<
    ProfileCreateWithoutMemberTypeInput[] | ProfileCreateWithoutMemberTypeInput
  >;
  connect?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
}

export interface ProfileCreateWithoutMemberTypeInput {
  id?: Maybe<ID_Input>;
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressCreateOneInput>;
  hometown?: Maybe<ProvinceCreateOneInput>;
  group?: Maybe<GroupCreateOneWithoutMembersInput>;
  leader?: Maybe<GroupCreateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceCreateManyWithoutMemberInput>;
}

export interface MemberTypeUpdateInput {
  name?: Maybe<String>;
  profiles?: Maybe<ProfileUpdateManyWithoutMemberTypeInput>;
}

export interface ProfileUpdateManyWithoutMemberTypeInput {
  create?: Maybe<
    ProfileCreateWithoutMemberTypeInput[] | ProfileCreateWithoutMemberTypeInput
  >;
  delete?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  connect?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  set?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  disconnect?: Maybe<ProfileWhereUniqueInput[] | ProfileWhereUniqueInput>;
  update?: Maybe<
    | ProfileUpdateWithWhereUniqueWithoutMemberTypeInput[]
    | ProfileUpdateWithWhereUniqueWithoutMemberTypeInput
  >;
  upsert?: Maybe<
    | ProfileUpsertWithWhereUniqueWithoutMemberTypeInput[]
    | ProfileUpsertWithWhereUniqueWithoutMemberTypeInput
  >;
  deleteMany?: Maybe<ProfileScalarWhereInput[] | ProfileScalarWhereInput>;
  updateMany?: Maybe<
    | ProfileUpdateManyWithWhereNestedInput[]
    | ProfileUpdateManyWithWhereNestedInput
  >;
}

export interface ProfileUpdateWithWhereUniqueWithoutMemberTypeInput {
  where: ProfileWhereUniqueInput;
  data: ProfileUpdateWithoutMemberTypeDataInput;
}

export interface ProfileUpdateWithoutMemberTypeDataInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressUpdateOneInput>;
  hometown?: Maybe<ProvinceUpdateOneInput>;
  group?: Maybe<GroupUpdateOneWithoutMembersInput>;
  leader?: Maybe<GroupUpdateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutMemberInput>;
}

export interface ProfileUpsertWithWhereUniqueWithoutMemberTypeInput {
  where: ProfileWhereUniqueInput;
  update: ProfileUpdateWithoutMemberTypeDataInput;
  create: ProfileCreateWithoutMemberTypeInput;
}

export interface MemberTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ProfileCreateInput {
  id?: Maybe<ID_Input>;
  oldId: ID_Input;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressCreateOneInput>;
  hometown?: Maybe<ProvinceCreateOneInput>;
  memberType?: Maybe<MemberTypeCreateOneWithoutProfilesInput>;
  group?: Maybe<GroupCreateOneWithoutMembersInput>;
  leader?: Maybe<GroupCreateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceCreateManyWithoutMemberInput>;
}

export interface ProfileUpdateInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressUpdateOneInput>;
  hometown?: Maybe<ProvinceUpdateOneInput>;
  memberType?: Maybe<MemberTypeUpdateOneWithoutProfilesInput>;
  group?: Maybe<GroupUpdateOneWithoutMembersInput>;
  leader?: Maybe<GroupUpdateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutMemberInput>;
}

export interface ProfileUpdateManyMutationInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
}

export interface ProvinceUpdateInput {
  name?: Maybe<String>;
  districts?: Maybe<DistrictUpdateManyWithoutProvinceInput>;
}

export interface ProvinceUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  password: String;
  role?: Maybe<Int>;
  active?: Maybe<Boolean>;
  profile?: Maybe<ProfileCreateOneInput>;
}

export interface ProfileCreateOneInput {
  create?: Maybe<ProfileCreateInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Int>;
  active?: Maybe<Boolean>;
  profile?: Maybe<ProfileUpdateOneInput>;
}

export interface ProfileUpdateOneInput {
  create?: Maybe<ProfileCreateInput>;
  update?: Maybe<ProfileUpdateDataInput>;
  upsert?: Maybe<ProfileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileUpdateDataInput {
  oldId?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Boolean>;
  email?: Maybe<String>;
  facebookId?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  joinDate?: Maybe<DateTimeInput>;
  dayOfBirth?: Maybe<Int>;
  monthOfBirth?: Maybe<Int>;
  yearOfBirth?: Maybe<Int>;
  address?: Maybe<AddressUpdateOneInput>;
  hometown?: Maybe<ProvinceUpdateOneInput>;
  memberType?: Maybe<MemberTypeUpdateOneWithoutProfilesInput>;
  group?: Maybe<GroupUpdateOneWithoutMembersInput>;
  leader?: Maybe<GroupUpdateOneWithoutLeaderInput>;
  attendances?: Maybe<ActivityAttendanceUpdateManyWithoutMemberInput>;
}

export interface ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput;
  create: ProfileCreateInput;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Int>;
  active?: Maybe<Boolean>;
}

export interface ActivityAttendanceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActivityAttendanceWhereInput>;
  AND?: Maybe<
    | ActivityAttendanceSubscriptionWhereInput[]
    | ActivityAttendanceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ActivityAttendanceSubscriptionWhereInput[]
    | ActivityAttendanceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ActivityAttendanceSubscriptionWhereInput[]
    | ActivityAttendanceSubscriptionWhereInput
  >;
}

export interface ActivityScheduleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActivityScheduleWhereInput>;
  AND?: Maybe<
    | ActivityScheduleSubscriptionWhereInput[]
    | ActivityScheduleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ActivityScheduleSubscriptionWhereInput[]
    | ActivityScheduleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ActivityScheduleSubscriptionWhereInput[]
    | ActivityScheduleSubscriptionWhereInput
  >;
}

export interface ActivityTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActivityTypeWhereInput>;
  AND?: Maybe<
    ActivityTypeSubscriptionWhereInput[] | ActivityTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    ActivityTypeSubscriptionWhereInput[] | ActivityTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ActivityTypeSubscriptionWhereInput[] | ActivityTypeSubscriptionWhereInput
  >;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AddressWhereInput>;
  AND?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  OR?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  NOT?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
}

export interface CommuneSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommuneWhereInput>;
  AND?: Maybe<CommuneSubscriptionWhereInput[] | CommuneSubscriptionWhereInput>;
  OR?: Maybe<CommuneSubscriptionWhereInput[] | CommuneSubscriptionWhereInput>;
  NOT?: Maybe<CommuneSubscriptionWhereInput[] | CommuneSubscriptionWhereInput>;
}

export interface DistrictSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DistrictWhereInput>;
  AND?: Maybe<
    DistrictSubscriptionWhereInput[] | DistrictSubscriptionWhereInput
  >;
  OR?: Maybe<DistrictSubscriptionWhereInput[] | DistrictSubscriptionWhereInput>;
  NOT?: Maybe<
    DistrictSubscriptionWhereInput[] | DistrictSubscriptionWhereInput
  >;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GroupWhereInput>;
  AND?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
  OR?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
  NOT?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
}

export interface MemberTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MemberTypeWhereInput>;
  AND?: Maybe<
    MemberTypeSubscriptionWhereInput[] | MemberTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    MemberTypeSubscriptionWhereInput[] | MemberTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MemberTypeSubscriptionWhereInput[] | MemberTypeSubscriptionWhereInput
  >;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProfileWhereInput>;
  AND?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  OR?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  NOT?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
}

export interface ProvinceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProvinceWhereInput>;
  AND?: Maybe<
    ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput
  >;
  OR?: Maybe<ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput>;
  NOT?: Maybe<
    ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ActivityAttendance {
  id: ID_Output;
  presence: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ActivityAttendancePromise
  extends Promise<ActivityAttendance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  schedule: <T = ActivitySchedulePromise>() => T;
  member: <T = ProfilePromise>() => T;
  presence: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityAttendanceSubscription
  extends Promise<AsyncIterator<ActivityAttendance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  schedule: <T = ActivityScheduleSubscription>() => T;
  member: <T = ProfileSubscription>() => T;
  presence: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActivityAttendanceNullablePromise
  extends Promise<ActivityAttendance | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  schedule: <T = ActivitySchedulePromise>() => T;
  member: <T = ProfilePromise>() => T;
  presence: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivitySchedule {
  id: ID_Output;
  start: DateTimeOutput;
  end: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ActivitySchedulePromise
  extends Promise<ActivitySchedule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  activity: <T = ActivityTypePromise>() => T;
  attendances: <T = FragmentableArray<ActivityAttendance>>(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityScheduleSubscription
  extends Promise<AsyncIterator<ActivitySchedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  activity: <T = ActivityTypeSubscription>() => T;
  attendances: <
    T = Promise<AsyncIterator<ActivityAttendanceSubscription>>
  >(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActivityScheduleNullablePromise
  extends Promise<ActivitySchedule | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  activity: <T = ActivityTypePromise>() => T;
  attendances: <T = FragmentableArray<ActivityAttendance>>(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityType {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ActivityTypePromise
  extends Promise<ActivityType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  schedules: <T = FragmentableArray<ActivitySchedule>>(args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityTypeSubscription
  extends Promise<AsyncIterator<ActivityType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  schedules: <T = Promise<AsyncIterator<ActivityScheduleSubscription>>>(args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActivityTypeNullablePromise
  extends Promise<ActivityType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  schedules: <T = FragmentableArray<ActivitySchedule>>(args?: {
    where?: ActivityScheduleWhereInput;
    orderBy?: ActivityScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Profile {
  id: ID_Output;
  oldId: ID_Output;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  joinDate?: DateTimeOutput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>;
  oldId: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Boolean>;
  email: () => Promise<String>;
  facebookId: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  joinDate: () => Promise<DateTimeOutput>;
  dayOfBirth: () => Promise<Int>;
  monthOfBirth: () => Promise<Int>;
  yearOfBirth: () => Promise<Int>;
  address: <T = AddressPromise>() => T;
  hometown: <T = ProvincePromise>() => T;
  memberType: <T = MemberTypePromise>() => T;
  group: <T = GroupPromise>() => T;
  leader: <T = GroupPromise>() => T;
  attendances: <T = FragmentableArray<ActivityAttendance>>(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  oldId: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  facebookId: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  joinDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dayOfBirth: () => Promise<AsyncIterator<Int>>;
  monthOfBirth: () => Promise<AsyncIterator<Int>>;
  yearOfBirth: () => Promise<AsyncIterator<Int>>;
  address: <T = AddressSubscription>() => T;
  hometown: <T = ProvinceSubscription>() => T;
  memberType: <T = MemberTypeSubscription>() => T;
  group: <T = GroupSubscription>() => T;
  leader: <T = GroupSubscription>() => T;
  attendances: <
    T = Promise<AsyncIterator<ActivityAttendanceSubscription>>
  >(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProfileNullablePromise
  extends Promise<Profile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  oldId: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Boolean>;
  email: () => Promise<String>;
  facebookId: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  joinDate: () => Promise<DateTimeOutput>;
  dayOfBirth: () => Promise<Int>;
  monthOfBirth: () => Promise<Int>;
  yearOfBirth: () => Promise<Int>;
  address: <T = AddressPromise>() => T;
  hometown: <T = ProvincePromise>() => T;
  memberType: <T = MemberTypePromise>() => T;
  group: <T = GroupPromise>() => T;
  leader: <T = GroupPromise>() => T;
  attendances: <T = FragmentableArray<ActivityAttendance>>(args?: {
    where?: ActivityAttendanceWhereInput;
    orderBy?: ActivityAttendanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Address {
  id: ID_Output;
  no?: String;
  street?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  no: () => Promise<String>;
  street: () => Promise<String>;
  commune: <T = CommunePromise>() => T;
  district: <T = DistrictPromise>() => T;
  province: <T = ProvincePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  no: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  commune: <T = CommuneSubscription>() => T;
  district: <T = DistrictSubscription>() => T;
  province: <T = ProvinceSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  no: () => Promise<String>;
  street: () => Promise<String>;
  commune: <T = CommunePromise>() => T;
  district: <T = DistrictPromise>() => T;
  province: <T = ProvincePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Commune {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface CommunePromise extends Promise<Commune>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  district: <T = DistrictPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommuneSubscription
  extends Promise<AsyncIterator<Commune>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  district: <T = DistrictSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommuneNullablePromise
  extends Promise<Commune | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  district: <T = DistrictPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface District {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface DistrictPromise extends Promise<District>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  communes: <T = FragmentableArray<Commune>>(args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  province: <T = ProvincePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface DistrictSubscription
  extends Promise<AsyncIterator<District>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  communes: <T = Promise<AsyncIterator<CommuneSubscription>>>(args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  province: <T = ProvinceSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DistrictNullablePromise
  extends Promise<District | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  communes: <T = FragmentableArray<Commune>>(args?: {
    where?: CommuneWhereInput;
    orderBy?: CommuneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  province: <T = ProvincePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Province {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ProvincePromise extends Promise<Province>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  districts: <T = FragmentableArray<District>>(args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ProvinceSubscription
  extends Promise<AsyncIterator<Province>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  districts: <T = Promise<AsyncIterator<DistrictSubscription>>>(args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProvinceNullablePromise
  extends Promise<Province | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  districts: <T = FragmentableArray<District>>(args?: {
    where?: DistrictWhereInput;
    orderBy?: DistrictOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MemberType {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface MemberTypePromise extends Promise<MemberType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  profiles: <T = FragmentableArray<Profile>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MemberTypeSubscription
  extends Promise<AsyncIterator<MemberType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  profiles: <T = Promise<AsyncIterator<ProfileSubscription>>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MemberTypeNullablePromise
  extends Promise<MemberType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  profiles: <T = FragmentableArray<Profile>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Group {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  members: <T = FragmentableArray<Profile>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leader: <T = ProfilePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  members: <T = Promise<AsyncIterator<ProfileSubscription>>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leader: <T = ProfileSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupNullablePromise
  extends Promise<Group | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  members: <T = FragmentableArray<Profile>>(args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leader: <T = ProfilePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityAttendanceConnection {
  pageInfo: PageInfo;
  edges: ActivityAttendanceEdge[];
}

export interface ActivityAttendanceConnectionPromise
  extends Promise<ActivityAttendanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityAttendanceEdge>>() => T;
  aggregate: <T = AggregateActivityAttendancePromise>() => T;
}

export interface ActivityAttendanceConnectionSubscription
  extends Promise<AsyncIterator<ActivityAttendanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ActivityAttendanceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateActivityAttendanceSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityAttendanceEdge {
  node: ActivityAttendance;
  cursor: String;
}

export interface ActivityAttendanceEdgePromise
  extends Promise<ActivityAttendanceEdge>,
    Fragmentable {
  node: <T = ActivityAttendancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityAttendanceEdgeSubscription
  extends Promise<AsyncIterator<ActivityAttendanceEdge>>,
    Fragmentable {
  node: <T = ActivityAttendanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivityAttendance {
  count: Int;
}

export interface AggregateActivityAttendancePromise
  extends Promise<AggregateActivityAttendance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityAttendanceSubscription
  extends Promise<AsyncIterator<AggregateActivityAttendance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityScheduleConnection {
  pageInfo: PageInfo;
  edges: ActivityScheduleEdge[];
}

export interface ActivityScheduleConnectionPromise
  extends Promise<ActivityScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityScheduleEdge>>() => T;
  aggregate: <T = AggregateActivitySchedulePromise>() => T;
}

export interface ActivityScheduleConnectionSubscription
  extends Promise<AsyncIterator<ActivityScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivityScheduleSubscription>() => T;
}

export interface ActivityScheduleEdge {
  node: ActivitySchedule;
  cursor: String;
}

export interface ActivityScheduleEdgePromise
  extends Promise<ActivityScheduleEdge>,
    Fragmentable {
  node: <T = ActivitySchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityScheduleEdgeSubscription
  extends Promise<AsyncIterator<ActivityScheduleEdge>>,
    Fragmentable {
  node: <T = ActivityScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivitySchedule {
  count: Int;
}

export interface AggregateActivitySchedulePromise
  extends Promise<AggregateActivitySchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityScheduleSubscription
  extends Promise<AsyncIterator<AggregateActivitySchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityTypeConnection {
  pageInfo: PageInfo;
  edges: ActivityTypeEdge[];
}

export interface ActivityTypeConnectionPromise
  extends Promise<ActivityTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityTypeEdge>>() => T;
  aggregate: <T = AggregateActivityTypePromise>() => T;
}

export interface ActivityTypeConnectionSubscription
  extends Promise<AsyncIterator<ActivityTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivityTypeSubscription>() => T;
}

export interface ActivityTypeEdge {
  node: ActivityType;
  cursor: String;
}

export interface ActivityTypeEdgePromise
  extends Promise<ActivityTypeEdge>,
    Fragmentable {
  node: <T = ActivityTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityTypeEdgeSubscription
  extends Promise<AsyncIterator<ActivityTypeEdge>>,
    Fragmentable {
  node: <T = ActivityTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivityType {
  count: Int;
}

export interface AggregateActivityTypePromise
  extends Promise<AggregateActivityType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivityTypeSubscription
  extends Promise<AsyncIterator<AggregateActivityType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommuneConnection {
  pageInfo: PageInfo;
  edges: CommuneEdge[];
}

export interface CommuneConnectionPromise
  extends Promise<CommuneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommuneEdge>>() => T;
  aggregate: <T = AggregateCommunePromise>() => T;
}

export interface CommuneConnectionSubscription
  extends Promise<AsyncIterator<CommuneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommuneEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommuneSubscription>() => T;
}

export interface CommuneEdge {
  node: Commune;
  cursor: String;
}

export interface CommuneEdgePromise extends Promise<CommuneEdge>, Fragmentable {
  node: <T = CommunePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommuneEdgeSubscription
  extends Promise<AsyncIterator<CommuneEdge>>,
    Fragmentable {
  node: <T = CommuneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommune {
  count: Int;
}

export interface AggregateCommunePromise
  extends Promise<AggregateCommune>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommuneSubscription
  extends Promise<AsyncIterator<AggregateCommune>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DistrictConnection {
  pageInfo: PageInfo;
  edges: DistrictEdge[];
}

export interface DistrictConnectionPromise
  extends Promise<DistrictConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DistrictEdge>>() => T;
  aggregate: <T = AggregateDistrictPromise>() => T;
}

export interface DistrictConnectionSubscription
  extends Promise<AsyncIterator<DistrictConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DistrictEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDistrictSubscription>() => T;
}

export interface DistrictEdge {
  node: District;
  cursor: String;
}

export interface DistrictEdgePromise
  extends Promise<DistrictEdge>,
    Fragmentable {
  node: <T = DistrictPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DistrictEdgeSubscription
  extends Promise<AsyncIterator<DistrictEdge>>,
    Fragmentable {
  node: <T = DistrictSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDistrict {
  count: Int;
}

export interface AggregateDistrictPromise
  extends Promise<AggregateDistrict>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDistrictSubscription
  extends Promise<AsyncIterator<AggregateDistrict>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MemberTypeConnection {
  pageInfo: PageInfo;
  edges: MemberTypeEdge[];
}

export interface MemberTypeConnectionPromise
  extends Promise<MemberTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MemberTypeEdge>>() => T;
  aggregate: <T = AggregateMemberTypePromise>() => T;
}

export interface MemberTypeConnectionSubscription
  extends Promise<AsyncIterator<MemberTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MemberTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMemberTypeSubscription>() => T;
}

export interface MemberTypeEdge {
  node: MemberType;
  cursor: String;
}

export interface MemberTypeEdgePromise
  extends Promise<MemberTypeEdge>,
    Fragmentable {
  node: <T = MemberTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MemberTypeEdgeSubscription
  extends Promise<AsyncIterator<MemberTypeEdge>>,
    Fragmentable {
  node: <T = MemberTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMemberType {
  count: Int;
}

export interface AggregateMemberTypePromise
  extends Promise<AggregateMemberType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMemberTypeSubscription
  extends Promise<AsyncIterator<AggregateMemberType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProvinceConnection {
  pageInfo: PageInfo;
  edges: ProvinceEdge[];
}

export interface ProvinceConnectionPromise
  extends Promise<ProvinceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProvinceEdge>>() => T;
  aggregate: <T = AggregateProvincePromise>() => T;
}

export interface ProvinceConnectionSubscription
  extends Promise<AsyncIterator<ProvinceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProvinceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProvinceSubscription>() => T;
}

export interface ProvinceEdge {
  node: Province;
  cursor: String;
}

export interface ProvinceEdgePromise
  extends Promise<ProvinceEdge>,
    Fragmentable {
  node: <T = ProvincePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProvinceEdgeSubscription
  extends Promise<AsyncIterator<ProvinceEdge>>,
    Fragmentable {
  node: <T = ProvinceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProvince {
  count: Int;
}

export interface AggregateProvincePromise
  extends Promise<AggregateProvince>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProvinceSubscription
  extends Promise<AsyncIterator<AggregateProvince>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  username: String;
  password: String;
  role: Int;
  active: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Int>;
  active: () => Promise<Boolean>;
  profile: <T = ProfilePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  profile: <T = ProfileSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Int>;
  active: () => Promise<Boolean>;
  profile: <T = ProfilePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActivityAttendanceSubscriptionPayload {
  mutation: MutationType;
  node: ActivityAttendance;
  updatedFields: String[];
  previousValues: ActivityAttendancePreviousValues;
}

export interface ActivityAttendanceSubscriptionPayloadPromise
  extends Promise<ActivityAttendanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityAttendancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityAttendancePreviousValuesPromise>() => T;
}

export interface ActivityAttendanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityAttendanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityAttendanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityAttendancePreviousValuesSubscription>() => T;
}

export interface ActivityAttendancePreviousValues {
  id: ID_Output;
  presence: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ActivityAttendancePreviousValuesPromise
  extends Promise<ActivityAttendancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  presence: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityAttendancePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityAttendancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  presence: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActivityScheduleSubscriptionPayload {
  mutation: MutationType;
  node: ActivitySchedule;
  updatedFields: String[];
  previousValues: ActivitySchedulePreviousValues;
}

export interface ActivityScheduleSubscriptionPayloadPromise
  extends Promise<ActivityScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivitySchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivitySchedulePreviousValuesPromise>() => T;
}

export interface ActivityScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivitySchedulePreviousValuesSubscription>() => T;
}

export interface ActivitySchedulePreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  end: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ActivitySchedulePreviousValuesPromise
  extends Promise<ActivitySchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivitySchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivitySchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActivityTypeSubscriptionPayload {
  mutation: MutationType;
  node: ActivityType;
  updatedFields: String[];
  previousValues: ActivityTypePreviousValues;
}

export interface ActivityTypeSubscriptionPayloadPromise
  extends Promise<ActivityTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityTypePreviousValuesPromise>() => T;
}

export interface ActivityTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivityTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivityTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityTypePreviousValuesSubscription>() => T;
}

export interface ActivityTypePreviousValues {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ActivityTypePreviousValuesPromise
  extends Promise<ActivityTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  no?: String;
  street?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  no: () => Promise<String>;
  street: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  no: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommuneSubscriptionPayload {
  mutation: MutationType;
  node: Commune;
  updatedFields: String[];
  previousValues: CommunePreviousValues;
}

export interface CommuneSubscriptionPayloadPromise
  extends Promise<CommuneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommunePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommunePreviousValuesPromise>() => T;
}

export interface CommuneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommuneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommuneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommunePreviousValuesSubscription>() => T;
}

export interface CommunePreviousValues {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface CommunePreviousValuesPromise
  extends Promise<CommunePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommunePreviousValuesSubscription
  extends Promise<AsyncIterator<CommunePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DistrictSubscriptionPayload {
  mutation: MutationType;
  node: District;
  updatedFields: String[];
  previousValues: DistrictPreviousValues;
}

export interface DistrictSubscriptionPayloadPromise
  extends Promise<DistrictSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DistrictPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DistrictPreviousValuesPromise>() => T;
}

export interface DistrictSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DistrictSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DistrictSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DistrictPreviousValuesSubscription>() => T;
}

export interface DistrictPreviousValues {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface DistrictPreviousValuesPromise
  extends Promise<DistrictPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface DistrictPreviousValuesSubscription
  extends Promise<AsyncIterator<DistrictPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface GroupPreviousValues {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MemberTypeSubscriptionPayload {
  mutation: MutationType;
  node: MemberType;
  updatedFields: String[];
  previousValues: MemberTypePreviousValues;
}

export interface MemberTypeSubscriptionPayloadPromise
  extends Promise<MemberTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MemberTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MemberTypePreviousValuesPromise>() => T;
}

export interface MemberTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MemberTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MemberTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MemberTypePreviousValuesSubscription>() => T;
}

export interface MemberTypePreviousValues {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface MemberTypePreviousValuesPromise
  extends Promise<MemberTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MemberTypePreviousValuesSubscription
  extends Promise<AsyncIterator<MemberTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface ProfilePreviousValues {
  id: ID_Output;
  oldId: ID_Output;
  firstName: String;
  lastName: String;
  gender: Boolean;
  email?: String;
  facebookId?: String;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  joinDate?: DateTimeOutput;
  dayOfBirth?: Int;
  monthOfBirth?: Int;
  yearOfBirth?: Int;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  oldId: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Boolean>;
  email: () => Promise<String>;
  facebookId: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  joinDate: () => Promise<DateTimeOutput>;
  dayOfBirth: () => Promise<Int>;
  monthOfBirth: () => Promise<Int>;
  yearOfBirth: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  oldId: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  facebookId: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  joinDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dayOfBirth: () => Promise<AsyncIterator<Int>>;
  monthOfBirth: () => Promise<AsyncIterator<Int>>;
  yearOfBirth: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProvinceSubscriptionPayload {
  mutation: MutationType;
  node: Province;
  updatedFields: String[];
  previousValues: ProvincePreviousValues;
}

export interface ProvinceSubscriptionPayloadPromise
  extends Promise<ProvinceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProvincePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProvincePreviousValuesPromise>() => T;
}

export interface ProvinceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProvinceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProvinceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProvincePreviousValuesSubscription>() => T;
}

export interface ProvincePreviousValues {
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ProvincePreviousValuesPromise
  extends Promise<ProvincePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ProvincePreviousValuesSubscription
  extends Promise<AsyncIterator<ProvincePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  password: String;
  role: Int;
  active: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Int>;
  active: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Int>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Profile",
    embedded: false
  },
  {
    name: "MemberType",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Commune",
    embedded: false
  },
  {
    name: "District",
    embedded: false
  },
  {
    name: "Province",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "ActivityType",
    embedded: false
  },
  {
    name: "ActivitySchedule",
    embedded: false
  },
  {
    name: "ActivityAttendance",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://prisma.btngiadinh.com/vichurch-btngiadinh/dev`,
  secret: `$(env:PRISMA_MANAGEMENT_API_SECRET)`
});
export const prisma = new Prisma();
